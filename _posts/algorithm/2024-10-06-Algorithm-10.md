---
layout: post
title: 백준 1012 문제풀이
subtitle: ""
categories: cs
tags: Algorithm
comments: false
---

## 문제 링크

<https://www.acmicpc.net/problem/1012>

## 문제 설명

<img width="507" alt="image" src="https://github.com/user-attachments/assets/ee9d57b4-a325-4fb5-8cea-88980a0ae062">

차세대 영농인 한나는 강원도 고랭지에서 유기농 배추를 재배하기로 하였다. 
농약을 쓰지 않고 배추를 재배하려면 배추를 해충으로부터 보호하는 것이 중요하기 때문에, 한나는 해충 방지에 효과적인 배추흰지렁이를 구입하기로 결심한다. 
이 지렁이는 배추근처에 서식하며 해충을 잡아 먹음으로써 배추를 보호한다. 
특히, 어떤 배추에 배추흰지렁이가 한 마리라도 살고 있으면 이 지렁이는 인접한 다른 배추로 이동할 수 있어, 그 배추들 역시 해충으로부터 보호받을 수 있다. 
한 배추의 상하좌우 네 방향에 다른 배추가 위치한 경우에 서로 인접해있는 것이다.
한나가 배추를 재배하는 땅은 고르지 못해서 배추를 군데군데 심어 놓았다. 
배추들이 모여있는 곳에는 배추흰지렁이가 한 마리만 있으면 되므로 서로 인접해있는 배추들이 몇 군데에 퍼져있는지 조사하면 총 몇 마리의 지렁이가 필요한지 알 수 있다. 
예를 들어 배추밭이 아래와 같이 구성되어 있으면 최소 5마리의 배추흰지렁이가 필요하다. 
은 배추가 심어져 있지 않은 땅이고, 1은 배추가 심어져 있는 땅을 나타낸다.

## 문제 분석

미로가 나왔다? BFS, DFS중에 하나로 푼다.
지렁이는 해충을 잡아먹으면서 배추를 보호한다. 
지렁이가 살고 있으면 인접한 다른 배추로 이동한다? -> Connected Component(기계같이 생각해라)
근데 나는 최단거리를 찾는 것이 아니고, DFS가 더편해서 DFS를 이용해서 풀었다.
그리고 이 문제는 특히 테스트 케이스가 중요하다고 생각했는데 그 이유는 아래에서 설명하겠다.

## 코드

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[51][51];
bool visited[51][51];
int dy[4] = {-1,0,1,0};
int dx[4] = {0,1,0,-1};
int ny,nx,n,m,t,x,y,ret,k;

void dfs(int y, int x){
    visited[y][x] = 1;
    for(int i = 0; i < 4; i++){
        ny = y + dy[i];
        nx = x + dx[i];
        if(ny < 0 || ny >= n || nx < 0 || nx >= m){
            continue;
        }
        if(a[ny][nx] == 1){
            if(!visited[ny][nx]){
                dfs(ny,nx);
            }   
        }
    }
    return;
}

int main(){
    cin.tie(NULL);
    cout.tie(NULL);
    cin >> t;
    while(t--){
        fill(&a[0][0], &a[0][0] + 51 * 51, 0);
        fill(&visited[0][0], &visited[0][0] + 51 * 51, 0);
        ret = 0;
        cin >> m >> n >> k;
        for(int i = 0; i < k; i++){
            cin >> x >> y;
            a[y][x] = 1;
        }
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(a[i][j] == 1 && !visited[i][j]){
                    dfs(i,j);
                    ret++;
                }
            }
        }
        cout << ret << '\n';
    }
    return 0;
}
```

2차원 배열에서 연결된 배추의 개수를 세는 문제를 해결하기 위해 DFS(Depth First Search) 알고리즘을 사용한다.
주어진 배열에서 1인 셀을 찾아 그 셀과 연결된 모든 셀을 탐색하여 연결된 영역의 수를 계산하는 것이다. `Component`
dy와 dx 배열은 상하좌우로 이동하기 위한 방향 벡터를 정의한다. 
DFS 함수는 현재 셀을 방문 처리하고 인접한 셀을 탐색하여, 배추가 있는 셀(1)이면서 아직 방문하지 않은 셀에 대해 재귀적으로 DFS를 호출하여 연결된 셀들을 모두 탐색한다.
메인 함수에서는 테스트 케이스 수를 입력받고, 각 테스트 케이스마다 배열을 초기화한다. 
**이때 fill 함수를 사용하여 배열을 0으로 초기화하는데, 이는 각 테스트 케이스가 독립적으로 진행되어야 하므로 중요하다.** 
배열이 초기화되지 않으면 이전 테스트 케이스의 결과가 남아있게 되어 잘못된 계산이 발생할 수 있다. 
따라서 fill을 통해 배열을 초기화하여 각 테스트 케이스가 깨끗한 상태에서 시작되도록 한다.
배추의 위치를 입력받은 후, 모든 셀을 탐색하면서 1인 셀 중 방문하지 않은 셀을 발견하면 DFS를 호출하고, 이때마다 연결된 배추의 개수를 세는 ret 변수를 증가시킨다. 
마지막으로 각 테스트 케이스의 결과로 연결된 컴포넌트의 개수를 출력한다.

<img width="1132" alt="image" src="https://github.com/user-attachments/assets/efb491ea-fbce-4a7e-9261-ae86555433fa">

처음부터 완벽한 코드를 짤 수는 없었다. 코드가 길어지다 보니 ny,nx를 y,x로 탐색하여 메모리 초과가 발생함.. 디버깅을 중간중간 잘하자.

## Reference

나의 뇌