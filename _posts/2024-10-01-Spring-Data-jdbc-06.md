---
layout: post
title: Spring JDBC 06 - JDBC Transaction commit, rollback
subtitle: ''
categories: framework
tags: jpa
comments: false
---

## **트랜잭션** **사용법**

데이터 변경 쿼리를 실행하고 데이터베이스에 그 결과를 반영하려면 커밋 명령어인 `commit` 을 호출하고, 결과를 반영하고 싶지 않으면 롤백 명령어인 `rollback` 을 호출하면 된다.

- ***커밋을** **호출하기** **전까지는** **임시로** **데이터를** **저장***하는 것이다. 따라서 해당 트랜잭션을 시작한 세션(사용자)에게만 변경 데이터가 보이고 다른 세션(사용자)에게는 변경 데이터가 보이지 않는다.

## 신규 데이터 추가

<img width="693" alt="image" src="https://github.com/user-attachments/assets/f2221f73-f290-4305-996f-cd20a2c688cd">

- 세션1은 트랜잭션을 시작하고 신규 회원1, 신규 회원2를 DB에 추가했다. 아직 커밋은 하지 않은 상태이다.
- 새로운 데이터는 임시 상태로 저장된다.
- 세션1은 `select` 쿼리를 실행해서 본인이 입력한 신규 회원1, 신규 회원2를 조회할 수 있다.
    - 커밋을 하기 전까지 세션2는 세션1의 데이터 변경을 확인할 수 없다.
- 세션2는 `select` 쿼리를 실행해도 신규 회원들을 조회할 수 없다. 왜냐하면 세션1이 아직 커밋을 하지 않았기 때문이다.

## 커밋하지 않은 정보를 다른 세션에서 확인을 하게 된다면?

예를 들어서 커밋하지 않는 데이터가 보인다면, 세션2는 데이터를 조회했을 때 신규 회원1, 2가 보일 것이다. 따
라서 신규 회원1, 신규 회원2가 있다고 가정하고 어떤 로직을 수행할 수 있다. 그런데 세션1이 롤백을 수행하면
신규 회원1, 신규 회원2의 데이터가 사라지게 된다. 따라서 데이터 정합성에 큰 문제가 발생한다.
세션2에서 세션1이 아직 커밋하지 않은 변경 데이터가 보이다면, 세션1이 롤백 했을 때 심각한 문제가 발생할 수
있다. 따라서 커밋 전의 데이터는 다른 세션에서 보이지 않는다. 깃허브의 동작 과정이랑 비슷하다고 생각하면 된다.

## RollBack 호출

데이터베이스에 반영한 모든 데이터가 처음 상태로 복구된다.
수정하거나 삭제한 데이터도 `rollback` 을 호출하면 모두 트랜잭션을 시작하기 직전의 상태로 복구된다.

# 트랜잭션 - 자동 커밋과 수동 커밋

트랜잭션을 사용할 때, 자동 커밋(Autocommit)과 수동 커밋(Manual Commit)의 개념을 이해하는 것이 중요하다. 각각의 모드는 트랜잭션의 작동 방식에 큰 영향을 미친다.

## 데이터베이스 스키마

트랜잭션 예제를 실행하기 위한 데이터베이스 스키마는 다음과 같다.

```sql
DROP TABLE member IF EXISTS;
CREATE TABLE member (
    member_id VARCHAR(10),
    money INTEGER NOT NULL DEFAULT 0,
    PRIMARY KEY (member_id)
);
```

```markdown
# 트랜잭션 - 자동 커밋과 수동 커밋

트랜잭션을 사용할 때, 자동 커밋(Autocommit)과 수동 커밋(Manual Commit)의 개념을 이해하는 것이 중요하다. 각각의 모드는 트랜잭션의 작동 방식에 큰 영향을 미친다.

## 데이터베이스 스키마

트랜잭션 예제를 실행하기 위한 데이터베이스 스키마는 다음과 같다.

```sql
DROP TABLE member IF EXISTS;
CREATE TABLE member (
    member_id VARCHAR(10),
    money INTEGER NOT NULL DEFAULT 0,
    PRIMARY KEY (member_id)
);

```

## 자동 커밋 (Autocommit)

자동 커밋 모드가 설정되면, 각 쿼리 실행 직후에 자동으로 커밋이 호출된다. 이는 쿼리를 실행할 때마다 자동으로 트랜잭션이 커밋되기 때문에 편리하지만, 여러 쿼리를 그룹으로 묶어 트랜잭션을 처리하는 것이 불가능하다.

### 자동 커밋 설정

```sql
SET autocommit TRUE; // 자동 커밋 모드 설정
INSERT INTO member(member_id, money) VALUES ('data1', 10000); // 자동 커밋 발생
INSERT INTO member(member_id, money) VALUES ('data2', 10000); // 자동 커밋 발생

```

이 경우, 각 쿼리가 실행될 때마다 자동으로 커밋이 이루어지므로 원자성을 보장하지 못한다.

## 수동 커밋 (Manual Commit)

수동 커밋 모드에서는 트랜잭션을 명시적으로 시작하고 종료할 수 있다. 이 모드에서는 사용자가 `commit` 또는 `rollback`을 호출하여 트랜잭션을 완료하거나 취소해야 한다.

### 수동 커밋 설정

```sql
SET autocommit FALSE; // 수동 커밋 모드 설정
INSERT INTO member(member_id, money) VALUES ('data3', 10000);
INSERT INTO member(member_id, money) VALUES ('data4', 10000);
COMMIT; // 수동 커밋 발생
        
```

## 정리

- 수동 커밋 모드에서는 명시적으로 트랜잭션의 시작과 끝을 관리할 수 있어 데이터의 일관성을 유지할 수 있다.
- **트랜잭션의 원자성**: 트랜잭션은 일련의 작업이 모두 성공적으로 완료되어야 하며, 그렇지 않을 경우 모든 작업이 취소되어야 한다.
- **세션 유지**: 자동 커밋 모드나 수동 커밋 모드는 세션이 유지되는 동안 계속해서 적용된다. 따라서, 필요에 따라 언제든지 모드를 변경할 수 있다.
- **에러 처리**: 수동 커밋 모드에서는 에러가 발생했을 때 `rollback`을 사용하여 이전 상태로 되돌릴 수 있다. 이는 데이터 무결성을 유지하는 데 중요한 역할을 한다.
- **기본 설정**: 대부분의 데이터베이스는 기본적으로 자동 커밋 모드로 설정되어 있으므로, 트랜잭션을 제대로 사용하기 위해서는 수동 커밋 모드로 설정하는 것이 필요하다.


## Reference

김영한님의 스프링 강의 정리