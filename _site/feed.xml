<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>일벌리는 개발자</title>
    <description>일을 벌여놔야 주워 담을 수 있습니다.
</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 30 Dec 2024 15:19:04 +0900</pubDate>
    <lastBuildDate>Mon, 30 Dec 2024 15:19:04 +0900</lastBuildDate>
    <generator>Jekyll v3.10.0</generator>
    
      <item>
        <title>Spring MVC 04 - Query Parameter</title>
        <description>&lt;h2 id=&quot;query&quot;&gt;Query&lt;/h2&gt;

&lt;p&gt;쿼리는 ‘문의’ 또는 ‘물음표’라는 사전적 의미를 가지고 있다. 쿼리 파라미터는 URL 뒤에 물음표 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;?&lt;/code&gt;와 함께 붙는 키-값(key-value)
쌍이다. 여래 개의 파라미터를 전달하려면 파라미터 사이에 앰퍼샌드 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt;를 추가해서 하나의 문자열(string)으로 전달한다.
쿼리 파라미터로는 문자열뿐만 아니라 숫자, 리스트 등 다양한 형태의 데이터를 넣을 수 있다.
쿼리 파라미터는 다양한 용도가 있는데, 웹 서버의 요청에 대한 추가 정보를 제공한다.&lt;/p&gt;

&lt;h2 id=&quot;그럼-언제가-적절할까&quot;&gt;그럼 언제가 적절할까?&lt;/h2&gt;

&lt;p&gt;Query parameter는 url에서 특정한 조건을 주고싶을 때 사용하는 것이 적절하다.
같은 API를 호출한다고 해도, 서로 다른 조건을 나열하는 것이 필요한 상황에 사용한다.
같은 신발 목록 데이터를 호출 하는데, 신상품 순, 사이즈가 250인 데이터만 따로, 260인 데이터만 따로, 낮은 가격순으로 데이터를 호출하는
API를 매번 새롭게 생성하는 것은 비효율적이다. 따라서 필요한 조건을 요청에 따라 선택적으로 처리할 수 있는 통일된 API를 구성할 때 사용한다.
쿼리 파라미터는 HTTP [GET], [DELETE] 요청에서만 사용하고, 유일 값을 식별하기 위한 용도가 아닌 옵션을 줄 때 사용한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;사이즈가 230인 신발 요청&lt;/strong&gt;&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  GET /shoes?size&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;230
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;가격이 낮은 순으로 정렬된 신발 요청&lt;/strong&gt;&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  GET /shoes?sort&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;price_asc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이처럼 쿼리 파라미터를 사용하면 하나의 API(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/shoes&lt;/code&gt;)로 다양한 조건의 데이터를 요청할 수 있으니 효율적이다.&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://www.slf4j.org&quot;&gt;http://www.slf4j.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://logback.qos.ch&quot;&gt;http://logback.qos.ch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-logging?&quot;&gt;https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-logging?&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 06 Dec 2024 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/framework/2024/12/06/Spring-framework-mvc-05/</link>
        <guid isPermaLink="true">http://localhost:4000/framework/2024/12/06/Spring-framework-mvc-05/</guid>
        
        <category>mvc</category>
        
        
        <category>framework</category>
        
      </item>
    
      <item>
        <title>SpringBoot Contribute</title>
        <description>&lt;h2 id=&quot;issue&quot;&gt;Issue&lt;/h2&gt;

&lt;p&gt;&lt;img width=&quot;654&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/79f345b0-d55c-497f-8e86-06ad21f9bf04&quot; /&gt;&lt;/p&gt;

&lt;p&gt;스프링에서 Open되어있는 이슈들에서 task를 받아서 기여할 수도 있지만 나는 평소 스프링이 어떻게 구조화 되어있는지 내심 궁금했기에 
하나하나 소스코드들을 읽어 보았다. 그러던 와중에 스프링에 문제아닌 문제? 마이너한 문제를 찾을 수 있었다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;654&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/07134b6a-2b24-4bd5-a93e-dde1c7d2e906&quot; /&gt;&lt;/p&gt;

&lt;p&gt;SpringBoot/http/client에 ReflectiveComponentsClientHttpRequestFactoryBuilder의 생성자에서 assert 오류 메시지 포맷을 개선한 변경 하였다.
기존의 오류 메시지가 문자열이 하드코딩되어 있어, 메시지 수정이나 로컬라이징 작업이 어려워 보였고 String.format()을 사용하여 동적으로 생성되도록 수정하였다.
사실 개선사항이 크게 필요는 없는 부분이지만 장기적으로 보았을 땐 변경되는 코드에 따라서 메시지의 포맷이 일관되게 유지되면 좋겠다고 생각했다.
그리고 무엇보다 오픈소스 생태계 그것도 스프링 오픈소스 생태계에 기여해볼 수 있다는 것이 가장 큰 동기부여가 되었다.&lt;/p&gt;

&lt;h2 id=&quot;변경&quot;&gt;변경&lt;/h2&gt;

&lt;p&gt;&lt;img width=&quot;654&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/80281847-748a-4534-9549-0d8e99939b56&quot; /&gt;&lt;/p&gt;

&lt;p&gt;매우 작고 간단했던 작업 내용이였지만 내가 직접 세계적인 오픈소스의 컨트리뷰터가 되기 위한 첫 걸음을 나아갔다는 점에서 상당히 뿌듯하다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;654&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/5c2992cb-3b2c-4abb-a4a3-5da7e1eb0b2e&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그리고 오픈소스들이라면 코딩 및 커밋 컨벤션을 가지고 있다. 해당 규칙을 만족해야 커밋이 반영이 된다. 
SpringBoot 같은 경우에는 &lt;a href=&quot;https://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html&quot;&gt;여기&lt;/a&gt;에서 컨벤션 규칙을 정리해두었다. 꼭 읽고 커밋하자&lt;/p&gt;

</description>
        <pubDate>Tue, 03 Dec 2024 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/opensource/2024/12/03/SpringBoot-contribute-01/</link>
        <guid isPermaLink="true">http://localhost:4000/opensource/2024/12/03/SpringBoot-contribute-01/</guid>
        
        <category>opensource</category>
        
        
        <category>opensource</category>
        
      </item>
    
      <item>
        <title>Spring MVC 04 - RequestParameter - Query</title>
        <description>&lt;h2 id=&quot;client-to-server&quot;&gt;Client to Server&lt;/h2&gt;

&lt;h3 id=&quot;get---쿼리-파라미터&quot;&gt;GET - 쿼리 파라미터&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;/url ?username = hello&amp;amp;age=20
    &lt;ul&gt;
      &lt;li&gt;메시지 바디 없이 URL의 쿼리 파라미터에 데이터를 포함해서 전달&lt;/li&gt;
      &lt;li&gt;검색 필터, 페이징등에서 많이 사용하는 방식&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;post---html-form&quot;&gt;POST - HTML Form&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;content-type: application/x-www.form-urlencoded
    &lt;ul&gt;
      &lt;li&gt;회원 가입, 상품 주문, HTML Form 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;http-message-body&quot;&gt;HTTP Message body&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;HTTP API에서 주로 사용, JSON, XML, TEXT
    &lt;ul&gt;
      &lt;li&gt;데이터 형식은 주로 JSON 사용&lt;/li&gt;
      &lt;li&gt;POST, PUT, PATCH&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;http으로-요청-파라미터-조회&quot;&gt;HTTP으로 요청 파라미터 조회&lt;/h2&gt;

&lt;p&gt;&lt;img width=&quot;654&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/44d90888-6c4c-41f7-bfbf-753c695734f2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;654&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/6e7f3bde-4900-4aca-ada0-cc25aef49aa4&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;spring으로-요청-파라미터-조회&quot;&gt;Spring으로 요청 파라미터 조회&lt;/h2&gt;

&lt;p&gt;&lt;img width=&quot;654&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/0d004f0c-0196-4650-93bc-66cdce712724&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;RequestParam을 사용하면 요청 파리미터를 쉽게 사용할 수 있다.&lt;/li&gt;
  &lt;li&gt;@Controller이면서 반환타입이 String 이면 ok라는 뷰를 찾게 된다.&lt;/li&gt;
  &lt;li&gt;따라서 클래스 레벨에서 @RestController로 변경해주거나, 메소드 레벨에서 @ReponseBody를 사용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img width=&quot;654&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/8420783a-23ca-48ac-b6b2-6ed155fb4d7c&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;String, int 등의 단순 타입이면 @RequestParam 도 생략 가능&lt;/li&gt;
  &lt;li&gt;String, int, Integer 등의  단순 타입이면 @RequestParam 도 생략가능
    &lt;ul&gt;
      &lt;li&gt;이렇게 애노테이션을 완전히 생략해도 되는데, 너무 없는 것도 약간 과하다는 주관적 생각이 있다.
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@RequestParam&lt;/code&gt; 이 있으면 명확하게 요청 파리미터에서 데이터를 읽는 다는 것을 알 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img width=&quot;654&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/6445a22e-592e-437a-bc40-4c2285a46102&quot; /&gt;&lt;/p&gt;

&lt;p&gt;(와중에 FHD, MAC 화질차이가..)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;RequiredParam 속성에서 기본값은 true이다. 아무것도 명시해주지 않는다면 false로 적용이 되어있다.&lt;/li&gt;
  &lt;li&gt;위의코드는 age는 필수값이 되어있고, username은 필수가 아니다.&lt;/li&gt;
  &lt;li&gt;또한 자바에서는 기본형은 null을 허용하지 않고, Integer(객체)는 null을 허용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;modelattribute&quot;&gt;ModelAttribute&lt;/h2&gt;

&lt;p&gt;&lt;img width=&quot;654&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/40b5bb13-6c54-4485-94e0-ecff9255615e&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ModelAttribute를 활용해보기 위해서 HelloData 객체 생성&lt;/li&gt;
  &lt;li&gt;Lombok이 제공해주는 @Data로 @Getter, @Setter, @ToString, @EqualsAndHashCode, @RequiredArgsConstructor를 자동으로 적용해준다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img width=&quot;654&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/3bcf608d-0322-4665-984f-958497c1ab4f&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;위에 두 코드는 같은 기능을 하는 코드이다.&lt;/li&gt;
  &lt;li&gt;@ModelAttribute를 사용하면 @ModelAttribute는 HelloData 객체를 생성하고 요청 파라미터 이름으로 HelloData 객체의 프로퍼티를 찾는다. 그리고 해당 프로퍼티의 setter를 호출해서 파라미터 값을 입력한다.
    &lt;ul&gt;
      &lt;li&gt;파라미터 이름이 username이라면 setUsername() 메서드를 찾아서 호출하면서 값을 입력해준다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img width=&quot;654&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/ef23de6e-38e9-4ce8-b14c-b5581cd1ceff&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@ModelAttribute&lt;/code&gt; 는 생략할 수 있다. 그런데 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@RequestParam&lt;/code&gt;도 생략할 수 있으니 혼란이 발생할 수 있다.&lt;/li&gt;
  &lt;li&gt;스프링은 해당 생략시 다음과 같은 규칙을 적용한다.
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;String&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Integer&lt;/code&gt; 같은 단순 타입 = &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@RequestParam&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;나머지 = &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@ModelAttribute&lt;/code&gt; (argument resolver 로 지정해둔 타입 외)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://www.slf4j.org&quot;&gt;http://www.slf4j.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://logback.qos.ch&quot;&gt;http://logback.qos.ch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-logging?&quot;&gt;https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-logging?&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 01 Dec 2024 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/framework/2024/12/01/Spring-framework-mvc-04/</link>
        <guid isPermaLink="true">http://localhost:4000/framework/2024/12/01/Spring-framework-mvc-04/</guid>
        
        <category>mvc</category>
        
        
        <category>framework</category>
        
      </item>
    
      <item>
        <title>Spring MVC 03 - Logger</title>
        <description>&lt;h2 id=&quot;logging-library&quot;&gt;Logging Library&lt;/h2&gt;

&lt;p&gt;운영 시스템에서는 System.out.println() 같은 시스템 콘솔을 사용해서 필요한 정보를 출력하지 않고, 
별도의 로깅 라이브러리를 사용해서 로그를 출력한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;로그 라이브러리는 Logback, Log4J, Log4J2등등 수 많은 라이브러리가 있는데, 그것을 통합해서 인터페이스로 제공하는 것이 바로 SLF4J 라이브러리다.&lt;/li&gt;
  &lt;li&gt;쉽게 이야기해서 SLF4J는 인터페이스이고, 그 구현체로 LogBack을 대부분 사용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;restcontroller-controller-차이&quot;&gt;RestController, Controller 차이?&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;@RestController
    &lt;ul&gt;
      &lt;li&gt;@Controller는 반환 값이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;String&lt;/code&gt; 이면 뷰 이름으로 인식된다. 그래서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;뷰를 찾고 렌더링&lt;/code&gt; 된다.&lt;/li&gt;
      &lt;li&gt;@RestController는 반환 값을초 뷰를 찾는 것이 아니라, HTTP 메시지 바디에 바로 입력 한다. 따라서 실행 결과로 ok 메시지를 받을 수 있다. @ResponseBody와 관련이 있는데, 뒤에서 더 자세히 설명한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;올바른-로그-사용법&quot;&gt;올바른 로그 사용법&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/user-attachments/assets/76665cb7-f66e-4866-88bd-24cec95b34fe&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;info log&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같은 형식으로 로그를 출력하면 안된다.
이유는 로그를 출력하기 전에 이미 더해지는 연산이 일어나기 때문이다.&lt;/p&gt;

&lt;h2 id=&quot;로그-사용시-장점&quot;&gt;로그 사용시 장점&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;쓰레드 정보, 클래스 이름 같은 부가 정보를 함께 볼 수 있고, 출력 모양을 조정할 수 있다.&lt;/li&gt;
  &lt;li&gt;로그 레벨에 따라 개발 서버에서는 모든 로그를 출력하고, 운영서버에서는 출력하지 않는 등 로그를 상황에 맞게 조절할 수 있다.&lt;/li&gt;
  &lt;li&gt;시스템 아웃 콘솔에만 출력하는 것이 아니라, 파일이나 네트워크 등, 로그를 별도의 위치에 남길 수 있다. 특히 파일로 남길 때는 일별, 특정 용량에 따라 로그를 분할하는 것도 가능하다.&lt;/li&gt;
  &lt;li&gt;성능도 일반 System.out보다 좋다. (내부 버퍼링, 멀티 쓰레드 등등) 그래서 실무에서는 꼭 로그를 사용해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://www.slf4j.org&quot;&gt;http://www.slf4j.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://logback.qos.ch&quot;&gt;http://logback.qos.ch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-logging?&quot;&gt;https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-logging?&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 29 Nov 2024 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/framework/2024/11/29/Spring-framework-mvc-03/</link>
        <guid isPermaLink="true">http://localhost:4000/framework/2024/11/29/Spring-framework-mvc-03/</guid>
        
        <category>mvc</category>
        
        
        <category>framework</category>
        
      </item>
    
      <item>
        <title>운영체제의 역사</title>
        <description>&lt;h2 id=&quot;운영체제-역사&quot;&gt;운영체제 역사&lt;/h2&gt;

&lt;p&gt;운영체제 역사를 아는 것은 지금의 컴퓨터를 이해하는데 있어서 밑거름이 된다고 한다.&lt;/p&gt;

&lt;h2 id=&quot;1940년대---초창기-컴퓨터&quot;&gt;1940년대 - 초창기 컴퓨터&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/user-attachments/assets/0fdaeedd-6269-4fa5-aee5-9470ff51323f&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;에니악은 펜실베이니아대학의 존 모클리John Mauclily 와 존 에커트Jolin Eckert 가 만들었다. 전선을 잭에 꼽아 회로를 연결하여 구성한 에니악은 30톤 규모의 거대한 계산기로 미사일 탄도를 계산하기 위해 제작&lt;/li&gt;
  &lt;li&gt;진공관이 켜지면 1, 진공관이 꺼지면 0 진공관은 백열전구를 말한다.&lt;/li&gt;
  &lt;li&gt;하드어와이링 방식&lt;/li&gt;
  &lt;li&gt;전선이 18000여개 정도 이어짐&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;1950년대---일괄-작업-시스템&quot;&gt;1950년대 - 일괄 작업 시스템&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/user-attachments/assets/c8908e34-6dd8-42ec-9170-79191b1db9ff&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;옛날 컴퓨터들이라 사진이 다 흑백임..&lt;/li&gt;
  &lt;li&gt;일괄작업시스템(batch-job-system)
    &lt;ul&gt;
      &lt;li&gt;현대는 여러가지 작업이 가능하지만 당시에는 한 번에 한 가지 작업만 가능했음
        &lt;ul&gt;
          &lt;li&gt;batch-job-system, batch-processing-system이라 하는데 프로그램 실행 중간에 사용자는 데이터를 수정할 수 없게 되어있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;CPU와 메인메모리가 있었으나, 키보드와 모니터와 같은 출력장치가 존재하지 않았음&lt;/li&gt;
  &lt;li&gt;천공카드 리더를 입력장치로 라인 프린터를 출력장치로 사용함
    &lt;ul&gt;
      &lt;li&gt;천공카드 리더는 펜으로 표시하여 데이터를 수집하는 방식과는 달리 구멍을 뚫어 숫자를 표현했다.&lt;/li&gt;
      &lt;li&gt;라인 프린터는 문자만 출력하는 프린터로 한 번에 한 줄씩 출력하기 때문에 라인 프린터라는 이름이 붙여졌다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;1960---대화형-시스템&quot;&gt;1960 - 대화형 시스템&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;옛날 컴퓨터의 방식은 천공 카드에 구멍을 뚫어 데이터를 적재하고 그 데이터를 읽는 방식으로 작업을 수행했다 따라서 중간에 데이터를 수정할 수가 없었다. 하지만 컴퓨터와 모니터가 등장한 이후에는 중간에 데이터를 수정할 수 있었다. 또한 중간 결과값을 출력하여 프로그램에 이상이 있는지 혹은 프로그램이 정상적으로 진행되고 있는지도 확인할 수 있게 되었다. 이러한 시스템은 컴퓨터와 사용자의 대화를 통해 작업이 이루어지므로 대화형 시스템(interactive system)이라고 일컫는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;1960-후반---시분할-시스템&quot;&gt;1960 후반 - 시분할 시스템&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;컴퓨터의 크기가 작아지고 계산 능력이 향상되었다. 하지만 허가받은 몇몇 사용자만 사용할 수 있는 데다 고가였다. 값비싼 기계로 한 번에 하나의 작업만 수행하는 것은 낭비라 효율적으로 사용하기 위한 연구가 진행된 결과 다중 프로그래밍multiprogramming 기술이 개발되었다.&lt;/li&gt;
  &lt;li&gt;일괄 작업 시스템은 CPU에서 한번에 하나의 작업만이 가능했지만 후반에는 CPU로 여러 작업을 동시에 실행할 수 있었다. 어떻게 ? 시간을 분할하는 방법으로&lt;/li&gt;
  &lt;li&gt;다중 프로그래밍 시스템에서는 CPU 사용 시간을 아즈 잘게 쪼개어 여러 작업으로 나누어 준다.&lt;/li&gt;
  &lt;li&gt;영화 필름을 생각해보면 된다. 작은 시퀸스 조각으로 여럿 쪼개서 이어 붙이면 동영상이 되듯이 모든 작업을 조금씩 처리하여 작업이 동시에 이루어지는 것처럼 보이게 하는 것이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;1970년대---분산-시스템&quot;&gt;1970년대 - 분산 시스템&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;개인용 컴퓨터와 인터넷이 보급되면서 값이 싸고 크기가 작은 컴퓨터들을 하나로 묶어
대형 컴퓨터에 버금가는 시스템을 만들게 되었는데 이를 분산 시스템distributed system이라고 부
른다. 분산 시스템은 네트워크상에 분산되어 있는 여러 컴퓨터로 작업을 처리하고 그 결과를
상호 교환하도록 구성한 시스템이다.&lt;/li&gt;
  &lt;li&gt;TCP/IP라는 프로토콜을 정의했다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;1990---클라이언트---서버-시스템&quot;&gt;1990 - 클라이언트 - 서버 시스템&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;작업을 요청하는 클라이언트와 거기에 응답하여 요청받은 작업을 처리하는 서버의 이중
구조로 나뉜다.&lt;/li&gt;
  &lt;li&gt;클라이언트/서버 구조가 일반인들에게 알려진 것은 웹 시스템이 보급된 이후이다.&lt;/li&gt;
  &lt;li&gt;웹 시스템의 등장으로 그림이나 링크를 통한 다양한 응용 서비스가 가능해졌다.&lt;/li&gt;
  &lt;li&gt;클라이언트/서버 구조의 문제점으로는 서버 과부하가 있다. 모든 요청이 서버로 집중되기 때문에 수십만 명의 클라이언트를 처리하기 위해서는 많은 서버와 큰 용량의 네트워크가 필요하다.&lt;/li&gt;
  &lt;li&gt;NOTE_DAEMON
    &lt;ul&gt;
      &lt;li&gt;클라이언트/서버 시스템 구조에서 서버가 멈추지 않고 계속 동작하여 클라이언트의 요청을 처리해야 하는데, 이렇게 멈추지 않고 계속 동작하는 프로그램을 데몬이라고 한다. 보통은 데몬을 가진 컴퓨터를 서버라고 부르며, 웹 데몬이 설치된 컴퓨터는 웹 서버, FTP 데몬이 설치된 컴퓨터는 FTP 서버, 이메일 데몬이 설치된 컴퓨터는 이메일 서버라고 한다. 웹 데몬의 역할을 하는 프로그램은 아파티 톰캣, Internet Informantion Service등이 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2000년대-초반---현재---p2p-시스템&quot;&gt;2000년대 초반 - 현재 - P2P 시스템&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;1990년대 말에 전 세계의 MP3 음악 파일을 공유하려는 시도가 있었는데 문제는 클라이언트/서버 시스템의 서버 과부하였다. 웹 페이지는 한 페이지가 수 킬로바이트이지만 MP3 파일은 수 메가바이트에 달하기 때문에 기존의 클라이언트/서버 구조로 MP3 파일 공유 시스템을 구현하면 서버 과부하가 걸림&lt;/li&gt;
  &lt;li&gt;서버의 부하를 줄일 수 있는 새로운 시스템은 P2P 시스템이다.&lt;/li&gt;
  &lt;li&gt;peer는 말단 노드, 즉 사용자의 PC를 가르키고, P2P는 서버를 거치지 않고, 사용자와 사용자를 직접 연결을 한다. P2P 시스템에서는 서버가 파일 검색만 맡고 사용자 간에 파일 전송이 이루어지기 때문에 서버의 부하가 적다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic_logic_unit&quot;&gt;https://en.wikipedia.org/wiki/Arithmetic_logic_unit&lt;/a&gt;
&lt;a href=&quot;https://www.techtarget.com/whatis/definition/arithmetic-logic-unit-ALU&quot;&gt;https://www.techtarget.com/whatis/definition/arithmetic-logic-unit-ALU&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 27 Nov 2024 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/cs/2024/11/27/Operating-system-02/</link>
        <guid isPermaLink="true">http://localhost:4000/cs/2024/11/27/Operating-system-02/</guid>
        
        <category>OS</category>
        
        
        <category>cs</category>
        
      </item>
    
      <item>
        <title>Kotlin In Action 02 - Statement, Expression</title>
        <description>&lt;h2 id=&quot;statement-expression&quot;&gt;Statement, Expression&lt;/h2&gt;

&lt;p&gt;코틀린은 satement보다 expression을 지양하는 언어이다. 
이때 이 둘의 차이는 무엇일까? Expression은 ‘수식’이라는 뜻이다. 
Expression들은 평가(evaluate)가 가능하기 때문에 하나 이상의 값으로 환원될 수 있다. 
Expression은 값을 가지기 때문에 다른 expression의 일부분으로 사용될 수 있다. 
그러나 satement는 ‘서술’이라는 뜻으로, 프로그래밍에서는 실행 가능한(executable) 최소의 독립적인 코드 조각을 일컫는다. 
스스로 값을 가지지 않는다는 점이 expression과의 차이점이 된다.&lt;/p&gt;

&lt;h2 id=&quot;자바의-if-statement&quot;&gt;&lt;strong&gt;자바의 if (Statement)&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;자바에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;if&lt;/code&gt;는 &lt;strong&gt;Statement&lt;/strong&gt;이다. 
즉, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;if&lt;/code&gt;는 단순히 조건에 따라 &lt;strong&gt;코드를 실행&lt;/strong&gt;하거나 &lt;strong&gt;다른 코드 블록을 선택&lt;/strong&gt;하는 역할만 하고, 
그 자체로 값을 반환하지 않는다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위 코드에서 if문은 조건에 따라 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;max&lt;/code&gt; 값을 결정하지만, if문 자체는 아무런 값을 반환하지 않는다.
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;max&lt;/code&gt;는 if문을 사용하여 계산된 결과로 결정되며, 
if는 단지 &lt;strong&gt;코드를 실행하는 역할&lt;/strong&gt;만 한다. 흐름만 제어하는 정도라고 생각하면 된다.&lt;/p&gt;

&lt;h2 id=&quot;코틀린의-if-expression&quot;&gt;&lt;strong&gt;코틀린의 if (Expression)&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;반면, 코틀린에서 if는 Expression&lt;strong&gt;이다&lt;/strong&gt;. 즉, if는 조건에 따라 &lt;strong&gt;결과값을 반환&lt;/strong&gt;할 수 있다. 
코틀린에서는 if가 &lt;strong&gt;값을 가지는 표현식&lt;/strong&gt;으로 취급되기 때문에, 
if문을 바로 변수에 할당하거나 다른 표현식의 일부로 사용할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;max&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;max&lt;/code&gt; 변수는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;if&lt;/code&gt;문이 반환한 값을 그대로 받는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;왜-이런-차이가-있을까&quot;&gt;왜 이런 차이가 있을까?&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;자바는 기본적으로 모든 조건문이 &lt;strong&gt;Statement&lt;/strong&gt;로 작동하며, 실행의 흐름을 제어하는 데 초점을 맞추기 때문에 if문이 값을 반환하지 않는다.&lt;/li&gt;
  &lt;li&gt;코틀린은 &lt;strong&gt;Expression 중심&lt;/strong&gt; 언어로 설계되었다. 그래서 if와 같은 조건문도 하나의 &lt;strong&gt;값&lt;/strong&gt;으로 취급하여 코드가 더 간결하고, 표현식으로 값을 바로 처리할 수 있도록 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://www.yes24.com/product/goods/55148593&quot;&gt;https://www.yes24.com/product/goods/55148593&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 25 Nov 2024 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/language/2024/11/25/Kotlin-basic-02/</link>
        <guid isPermaLink="true">http://localhost:4000/language/2024/11/25/Kotlin-basic-02/</guid>
        
        <category>kotlin</category>
        
        
        <category>language</category>
        
      </item>
    
      <item>
        <title>Kotlin In Action 01 - 코틀린 철학</title>
        <description>&lt;p&gt;프로그래밍 언어, 프레임워크를 공부하다 보면 왜 배워야 하는지, 
어떤 목적으로 만들어졌는지에 대한 생각이 가장 많이 난다. 
굳이 왜 잘쓰고 있는 자바를 대체하면서 Kotlin으로 마이그레이션을 하는지 궁금했다. 
그래서 Kotlin in Action이라는 책을 읽으며 왜 Kotlin을 써야하는지 어떤 부분에서 좋은지 알고 싶었다.
회사에서 안드로이드 개발도 해야하니 Kotlin을 주언어로 써야하기도 한다. (사실 이게 가장 큼)&lt;/p&gt;

&lt;h2 id=&quot;실용성&quot;&gt;실용성&lt;/h2&gt;

&lt;h3 id=&quot;코틀린은-실전-문제를-해결하기-위해-만든-실용적인-언어&quot;&gt;코틀린은 실전 문제를 해결하기 위해 만든 실용적인 언어&lt;/h3&gt;

&lt;p&gt;코틀린은 연구를 위한 언어가 아니기 때문에, 
최신 프로그래밍에 앞서 채택하지 않고, 
다른 프로그래밍 언어가 채택한 이미 성공적으로 검증된 해법과 기능에 의존한다고 한다. 
이러한 장점이 언어의 복잡도가 줄어들고 이미 알고 있는 기존 개념을 통해 쉽게 배울 수가 있다. 
기존 자바의 라이브러리 기능을 그대로 사용할 수 있다는 말 인 것 같다.&lt;/p&gt;

&lt;h3 id=&quot;코틀린은-어느-특정-프로그래밍-스타일이나-패러다임을-사용하는-것을-강제로-요구x&quot;&gt;코틀린은 어느 특정 프로그래밍 스타일이나 패러다임을 사용하는 것을 강제로 요구X&lt;/h3&gt;

&lt;p&gt;코틀린을 처음 배우는 사람은 자바에서 사용해 온 익숙한 프로그래밍 스타일이나 기법을 활용할 수 있고, 
나중에 코틀린의 강력한 특성을 발견하고 적응 해나가 더 간결한 코드를 작성하라고 한다.&lt;/p&gt;

&lt;h2 id=&quot;간결성&quot;&gt;&lt;strong&gt;간결성&lt;/strong&gt;&lt;/h2&gt;

&lt;h3 id=&quot;코틀린은-코드가-더-간단하고-간결할수록-내용을-파악하기-더-좋다&quot;&gt;&lt;strong&gt;코틀린은 코드가 더 간단하고 간결할수록 내용을 파악하기 더 좋다&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;어떤 언어가 간결하다는 말은 그 언어로 작성된 코드를 읽을 때 의도를 쉽게 파악할 수 있는 구문 구조를 제공하고, 
그 의도를 달성하는 방법을 이해할 때 방해가 될 수 있는 부가적인 준비 코드가 적다는 뜻이다.&lt;/p&gt;

&lt;h3 id=&quot;코틀린은-boiler-plate-코드를-줄임&quot;&gt;&lt;strong&gt;코틀린은 boiler plate 코드를 줄임&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;코틀린은 &lt;strong&gt;Setter, Setter, Constructor&lt;/strong&gt; 묵시적으로 제공하기 때문에 코틀린 소스코드는 boiler plate 코드를 줄였다고 한다.&lt;/p&gt;

&lt;h2 id=&quot;안정성&quot;&gt;안정성&lt;/h2&gt;

&lt;h3 id=&quot;jvm에서-실행되는-정적-타입-지정-언어&quot;&gt;&lt;strong&gt;JVM에서 실행되는 정적 타입 지정 언어&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;JVM을 사용하면 메모리 안전성을 보장하고, 버퍼 오버플로우를 방지하며, 동적으로 할당한 메모리를 잘못 사용함으로 인해 발생할 수 있는 다양한 문제를 예방할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;컴파일-시점-검사를-통해-오류를-더-많이-방지&quot;&gt;&lt;strong&gt;컴파일 시점 검사를 통해 오류를 더 많이 방지&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;NullPointerException을 없애주기 위해 노력했다고 한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;코틀린의 타입 시스템은 null이 될 수 없는 값을 추적하며, 실행 시점에 NullPointerException이 발생할 수 있는 연산을 사용하는 코드를 금지한다.&lt;/p&gt;

&lt;h3 id=&quot;classcastexception을-방지해준다&quot;&gt;&lt;strong&gt;ClassCastException을 방지해준다.&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;코틀린은 어떤 객체를 다른 타입으로 캐스트하기 전에 타입을 미리 검사하지 않으면 ClassCastException이 발생한다.&lt;/p&gt;

&lt;h2 id=&quot;상호운용성&quot;&gt;&lt;strong&gt;상호운용성&lt;/strong&gt;&lt;/h2&gt;

&lt;h3 id=&quot;코틀린은-자바-표준-라이브러리-클래스에-의존하기-때문에-자바와-상호운용성이-좋다&quot;&gt;&lt;strong&gt;코틀린은 자바 표준 라이브러리 클래스에 의존하기 때문에 자바와 상호운용성이 좋다.&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;자바와 코틀린 소스 파일을 자유롭게 내비게이션 할 수 있다.
자바 메서드를 리팩터링 해도 그 메소드와 관련 있는 코틀린 코드까지 제대로 변경된다. 
역으로 코틀린 메소드를 리팩토링해도 자바 코드까지 모두 자동으로 변경된다고 한다.&lt;/p&gt;

&lt;p&gt;가자 Kotlin Deep Dive~~&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://www.yes24.com/product/goods/55148593&quot;&gt;https://www.yes24.com/product/goods/55148593&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 23 Nov 2024 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/language/2024/11/23/Kotlin-basic-01/</link>
        <guid isPermaLink="true">http://localhost:4000/language/2024/11/23/Kotlin-basic-01/</guid>
        
        <category>kotlin</category>
        
        
        <category>language</category>
        
      </item>
    
      <item>
        <title>Android 01 - Activity LifeCycle</title>
        <description>&lt;h2 id=&quot;activity&quot;&gt;Activity&lt;/h2&gt;

&lt;p&gt;액티비는 안드로이드 4대 컴포넌트 중에 하나이다. 앱을 실행했을 때 보이는 화면이다.
생명주기 메서드는 아래와 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/user-attachments/assets/c3b76366-53e5-4f3e-bcda-5c64cdb62427&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;onCreate()
    &lt;ul&gt;
      &lt;li&gt;액티비티가 최초 생성될 때 호출된다.&lt;/li&gt;
      &lt;li&gt;액티비티의 초기화 작업(레이아웃 설정, 데이터 바인딩, 리소스 초기화)를 수행한다.&lt;/li&gt;
      &lt;li&gt;한번만 호출된다.&lt;/li&gt;
      &lt;li&gt;생성된 화면 요소를 메모리에 로드한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;onStart()
    &lt;ul&gt;
      &lt;li&gt;액티비티가 사용자에게 보여지기 시작할 때 호출된다.&lt;/li&gt;
      &lt;li&gt;화면이 표시되기 직전에 준비 상태로 들어간다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;onResume()
    &lt;ul&gt;
      &lt;li&gt;액티비티가 사용자와 상호작용 가능한 상태로 전환될 때 호출된다.&lt;/li&gt;
      &lt;li&gt;화면이 포커스를 얻고, 이벤트를 받을 수 있는 상태이다(터치, 키 입력)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;onPause()
    &lt;ul&gt;
      &lt;li&gt;액티비티가 다른 화면에 의해 부분적으로 가려지거나 비활성화될 때 호출된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;onStop()
    &lt;ul&gt;
      &lt;li&gt;액티비티가 완전히 화면에서 보이지 않을 때 호출된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;onDestroy()
    &lt;ul&gt;
      &lt;li&gt;액티비티가 완전히 종료될 때 호출된다.&lt;/li&gt;
      &lt;li&gt;시스템이 메모리를 회수하거나, 사용자가 앱을 종료할 때 호출된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;onPause() → onStop()
    &lt;ul&gt;
      &lt;li&gt;현재 액티비티를 종료하지 않고 새로운 액티비티가 만들어질 때(Stopped) 상태&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;onStart() → onResume()
    &lt;ul&gt;
      &lt;li&gt;두 메서드가 연속적으로 실행되고 Resumed 상태로 변경된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;생명주기를 쉽게 이해하려면 실제 화면에 표시 유무를 생각하면 된다. 
먼저 최초로 앱을 실행하면 onCreate()가 호출된다. 이때 초기화 관련 작업을 하면 좋다. 
다음으로 onStart()가 호출이되고 이 시점부터 사용자가 액티비티를 볼 수 있다. 
그리고 액티비티가 실제 사용자와 상호작용이 가능한 포그라운드에 위치하면 onResume()이 호출된다. 
이 상태를 액티비티가 실행 중인 것으로 본다.
반대로 액티비티가 실행 중인 상태에서 사용자와 상호작용이 불가능한 상태, 즉 포커스를 잃은 상태가 되면 onPause()가 호출된다. 
onStop()은 액티비티가 더 이상 보이지 않을 때 호출된다. 
그리고 액티비티가 종료되거나 앱 프로세스 자체가 종료되면 onDestroy()가 호출된다.
주의할 점은 불투명한 새로운 액티비티가 최상단으로 올라와서 기존 액티비티가 완전히 보이지 않게 되면 onPause()에 이어서 바로 onStop()까지 호출된다.
안드로이드 열시미 해야겠다. 코루틴도 공부해야지&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://source.android.com/docs?hl=ko&quot;&gt;https://source.android.com/docs?hl=ko&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 19 Nov 2024 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/framework/2024/11/19/Kotlin-android-01/</link>
        <guid isPermaLink="true">http://localhost:4000/framework/2024/11/19/Kotlin-android-01/</guid>
        
        <category>android</category>
        
        
        <category>framework</category>
        
      </item>
    
      <item>
        <title>Spring MVC 02 - Adapter Pattern</title>
        <description>&lt;h2 id=&quot;adapter-pattern&quot;&gt;Adapter Pattern&lt;/h2&gt;

&lt;p&gt;어댑터 패턴(Adapter Pattern)은 구조적 디자인 패턴의 하나로, 서로 호환되지 않는 인터페이스를 가진 클래스들을 연결하여 함께 동작할 수 있도록 돕는 역할을 한다. 
즉, 클라이언트가 기존 클래스나 인터페이스를 사용할 수 있게 “중간 다리 역할”을 하는 객체를 만드는 패턴이다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;654&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/111ef9aa-45ad-4579-9359-5bad5df6cf22&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;핸들러 어댑터
    &lt;ul&gt;
      &lt;li&gt;중간에 어댑터 역할을 하는 어댑터가 추가되었는데, 이름이 핸들러 어댑터이다. 여기서 어댑터 역할을 해주는 덕분에 다양한 종류의 컨트롤러를 호출할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;핸들러
    &lt;ul&gt;
      &lt;li&gt;컨트롤러의 이름을 더 넓힌 범위의 핸들러로 변경이 되었다. 그 이유는 이제 어댑터가 있기 때문에 꼭 컨트롤러의 개념 뿐만이 아니라 어떠한 것이든 해당하는 종류의 어댑터만 있으면 다 처리할 수 있기 때문이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img width=&quot;654&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/626fcd87-70c3-4d75-91a8-697663535631&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;boolean supports(Object handler)
    &lt;ul&gt;
      &lt;li&gt;handler는 컨트롤러를 말한다.&lt;/li&gt;
      &lt;li&gt;어댑터가 해당 컨트롤러를 처리할 수 있는지 판단하는 메서드다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ModelView handle(HttpServletRequest request, HttpServletResponse response, Object handler)
    &lt;ul&gt;
      &lt;li&gt;어댑터는 실제 컨트롤러를 호출하고, 그 결과로 ModelView를 반환해야 한다.&lt;/li&gt;
      &lt;li&gt;실제 컨트롤러가 ModelView를 반환하지 못하면, 어댑터가 ModelView를 직접 생성해서라도 반환해야
한다.&lt;/li&gt;
      &lt;li&gt;이전에는 프론트 컨트롤러가 실제 컨트롤러를 호출했지만 이제는 이 어댑터를 통해서 실제 컨트롤러가 호출 된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img width=&quot;654&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/7dba62de-f27a-44dc-bf24-da773579a47f&quot; /&gt;&lt;/p&gt;

&lt;p&gt;코드를 잘보면 위의 그림을 그대로 표현한 것이다.
클라이언트가 요청을 하면 일단 핸들러 맵핑 정보를 뒤져본다.
핸들러를 처리할 수 있는 핸들러 어댑터를 getHandler 어댑터에다가 이 핸들러를 던지면서 V3 컨트롤러에 대한 걸 처리할 수 있는 핸들러 어댑터를 찾아온다.
그러면 V3 컨트롤러를 바꾼 다음 컨트롤러의 프로세서를 호출한다. 이후 모델뷰를 반환한다.&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.spring.io/spring-framework/docs/3.0.0.M4/spring-framework-reference/html/ch15s02.html&quot;&gt;https://docs.spring.io/spring-framework/docs/3.0.0.M4/spring-framework-reference/html/ch15s02.html&lt;/a&gt;
&lt;a href=&quot;https://docs.spring.io/spring-framework/reference/core/beans/dependencies/factory-collaborators.html&quot;&gt;https://docs.spring.io/spring-framework/reference/core/beans/dependencies/factory-collaborators.html&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 15 Nov 2024 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/framework/2024/11/15/Spring-framework-mvc-02/</link>
        <guid isPermaLink="true">http://localhost:4000/framework/2024/11/15/Spring-framework-mvc-02/</guid>
        
        <category>mvc</category>
        
        
        <category>framework</category>
        
      </item>
    
      <item>
        <title>CPU Outline</title>
        <description>&lt;h2 id=&quot;central-processing-unit&quot;&gt;Central Processing Unit&lt;/h2&gt;

&lt;p&gt;컴퓨터 시스템을 이루는 3 대 구성이 있다면 CPU, 메리 그리고 디스크이다. 
여기에 I/O 까지 추가 된다면 그것을 컴퓨터를 이루는 기본 골격이라고 할 수 있는데, 
이것을 제안한 것이 폰 노이만이다. 주요 특징은 명령어 → 데이터 로드 → 실행 → 저장을 순차적으로 수행하는 것과 데이터/프로그램을 하나의 버스로 접근하는 구조이다.
폰 노이만 구조는 중앙 처리 장치라는 것이 있고 이 중앙 처리 장치를 통해서 연산을 수행하게 되는 구조이다. 
이 CPU(중앙처리 장치)는 각종 연산을 수행하고 기억장치에 기억되어 있는 명령어들을 수행하는 컴퓨터 시스템을 이루는 핵심 부품이다.&lt;/p&gt;

&lt;h2 id=&quot;cpu의-속도-hz-clock&quot;&gt;CPU의 속도 Hz, Clock&lt;/h2&gt;

&lt;p&gt;CPU는 수를 계산하는 칩정도로 생각하면 된다. 원리가 덧셈기와 같이 동작한다.
컴퓨터의 성능을 CPU의 속도와 메모리의 용량으로 표현할 수 있다. 
시스템내의 CPU 에 전기적으로 공급되는 신호를 Clock 이라고 하는데, 
이것은 주기적으로 일정한 시그널을 보내주는 칩이다. Clock 에서는 일정 볼트로 주기적으로 신호를 발생한다. 
그러면 CPU 는 이 신호를 받고 데이터를 주거나 받고 처리하게 된다. 
전기적 신호 한번에 의해서 CPU에서는 한개의 명령을 처리한다. 
CPU 의 속도를 Hz 로 나타내고 이 Hz 가 높으면 속도가 빠른 성능의 CPU 가 되는 것이다. 
그래서 주사율이 높은 모니터를 쓰려면 CPU의 성능이 좋아야 하나보다.&lt;/p&gt;

&lt;h2 id=&quot;cpu의-구성도&quot;&gt;CPU의 구성도&lt;/h2&gt;

&lt;p&gt;&lt;img width=&quot;654&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/7db9bc08-41b1-4ccd-a1ac-4fc82bebaee0&quot; /&gt;&lt;/p&gt;

&lt;p&gt;CPU 의 내부 구성은 크게 산술/논리 연산 장치(ALU), 제어 장치와 레지스터로 구성되어 있다. 
산술은 덧셈을 수행하는 것이고, 제어 장치는 시그럴을 통해서 데이터 흐름을 통제하는 것이며 레지스터는 CPU 내부의 메모리이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Instruction Fetcher&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;컴퓨터의 프로세서(Processor)**에서 명령어(Instruction)를 가져오는 역할을 하는 컴포넌트이다. 프로세서는 프로그램의 명령어를 실행하기 위해 메모리에서 명령어를 가져와야 하는데, 이 과정이 Instruction Fetch라고 불린다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Instruction Decoder&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;읽어들인 명령어에 대해 수행할 동작을 결정하기 위해 명령어를 해독한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Register&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;프로세서에 위치한 고속 메모리로써 매우 적은 소량의 데이터나 자주 사용되는 결과값들을 미리 저장해두는 공간이다. 프로세서가 빠르게 레지스터를 참조하여 작업 속도를 증가시키는데 목적이 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ALU&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;산술 논리 장치의 경우에는 덧셈, 뺄셈과 같은 단순 산순연산부터 베타적 논리합, 논리곱과 같은 논리 연산을 수행한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;명령어-구조&quot;&gt;명령어 구조&lt;/h2&gt;
&lt;p&gt;&lt;img width=&quot;654&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/7164732b-bfee-4b0b-a0a1-32afb6aae3fa&quot; /&gt;&lt;/p&gt;

&lt;p&gt;명령어는 시스템이 특정 동작을 수행시키는 작은 단위이다. 명령어는 코드로 되어 있는데 아래와 같이 동작코드(Op-code: Operation Code)와 오퍼랜드(Operand)로 구성되어 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;명령어 = 동작코드 _ 오퍼랜드&lt;/li&gt;
  &lt;li&gt;동작코드 : 각 명령어의 실행 동작을 구분하여 표현&lt;/li&gt;
  &lt;li&gt;오퍼랜드 : 명령어의 실행에 필요한 자료나 실제 자료의 저장 위치&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;명령어-수행-과정&quot;&gt;명령어 수행 과정&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;CPU가 하나의 명령(Operation)을 처리하는 과정은 다음과 같다.&lt;/li&gt;
  &lt;li&gt;FI → DI → EI → WB&lt;/li&gt;
  &lt;li&gt;읽기(Fetch Instruction): 메모리에서 명령을 가져온다.&lt;/li&gt;
  &lt;li&gt;해석(Decode Instruction): 명령을 해석한다.&lt;/li&gt;
  &lt;li&gt;실행(Execute Instruction): 명령을 수행한다.&lt;/li&gt;
  &lt;li&gt;기록(Wrtie Back): 수행한 결과를 기록한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Program Counter는 Fetch 할 다음의 명령어 주소를 갖고 있다. 
(여기저기서 Fetch가 정말 많이 등장하는데 Fetch는 가져오다라는 어원을 가지고 있다. ) 
프로세스는 PC(ProgramCounter)가 가리키는 주소위치에서 명령어를 가져오면서 PC를 증가시키고 명령문은 Instruction Register에 Load 된다.
그리고 Load된 명령어는 Execute Cycle Fetch 과정에서 가져온 명령어를 실제 ALU(가산기)에서 처리하게 된다.&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;p&gt;나의 뇌&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic_logic_unit&quot;&gt;https://en.wikipedia.org/wiki/Arithmetic_logic_unit&lt;/a&gt;
&lt;a href=&quot;https://www.techtarget.com/whatis/definition/arithmetic-logic-unit-ALU&quot;&gt;https://www.techtarget.com/whatis/definition/arithmetic-logic-unit-ALU&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 11 Nov 2024 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/cs/2024/11/11/Operating-system-01/</link>
        <guid isPermaLink="true">http://localhost:4000/cs/2024/11/11/Operating-system-01/</guid>
        
        <category>OS</category>
        
        
        <category>cs</category>
        
      </item>
    
      <item>
        <title>Spring MVC 01 - FrontController</title>
        <description>&lt;h2 id=&quot;frontcontroller&quot;&gt;FrontController&lt;/h2&gt;

&lt;p&gt;&lt;img width=&quot;654&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/b757077e-b69d-471c-8131-ef8f894e07d4&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;FrontController &lt;strong&gt;패턴&lt;/strong&gt; &lt;strong&gt;특징&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;프론트 컨트롤러 서블릿 하나로 클라이언트의 요청을 받음 프론트 컨트롤러가 요청에 맞는 컨트롤러를 찾아서 호출 입구를 하나로! 공통 처리 가능 프론트 컨트롤러를 제외한 나머지 컨트롤러는 서블릿을 사용하지 않아도 됨&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;스프링&lt;/strong&gt; &lt;strong&gt;웹&lt;/strong&gt; MVC&lt;strong&gt;와&lt;/strong&gt; &lt;strong&gt;프론트&lt;/strong&gt; &lt;strong&gt;컨트롤러&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;스프링 웹 MVC의 핵심도 바로 &lt;strong&gt;FrontController&lt;/strong&gt; 스프링 웹 MVC의 &lt;strong&gt;DispatcherServlet&lt;/strong&gt;이 FrontController 패턴으로 구현되어 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;프론트 컨트롤러를 단계적으로 도입해보자. 이번 목표는 기존 코드를 최대한 유지하면서, 프론트 컨트롤러를 도입하는 것이다. 먼저 구조를 맞추어두고 코드를 짜보자&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;654&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/f5a6fac1-4ca1-41ef-9c06-047892253c6c&quot; /&gt;&lt;/p&gt;

&lt;p&gt;서블릿과 비슷한 모양의 컨트롤러 인터페이스를 도입한다. 각 컨트롤러들은 이 인터페이스를 구현하면 된다. 
프론트 컨트롤러는 이 인터페이스를 호출해서 구현과 관계없이 로직의 일관성을 가져갈 수 있다.
이제 이 인터페이스를 구현한 컨트롤러를 만들어보자. 지금 단계에서는 기존 로직을 최대한 유지하는게 핵심이다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;654&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/1b733f18-52f0-4811-9ef0-d1c8166ed0ce&quot; /&gt;
&lt;img width=&quot;654&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/ceab8ac4-35ba-454d-b1c0-8a4010d6e1ec&quot; /&gt;
&lt;img width=&quot;654&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/be88842e-9e37-48b7-81d8-cbfb5f9850ee&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;왜-controllerv1을-반환할까&quot;&gt;왜 ControllerV1을 반환할까?&lt;/h2&gt;

&lt;p&gt;&lt;img width=&quot;654&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/304f23ca-00b2-4d0a-8cc5-11b41bc1d22c&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이유는 ControllerMap에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;requestURI&lt;/code&gt;에 매핑된 값을 가져온다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;ControllerMap 값 타입은 ControllerV1
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;controllerMap&lt;/code&gt;은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Map&amp;lt;String, ControllerV1&amp;gt;&lt;/code&gt;로 선언되어 있다. 따라서, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.get(key)&lt;/code&gt; 메서드는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ControllerV1&lt;/code&gt; 타입을 반환한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;다형성 적용&lt;/strong&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ControllerV1&lt;/code&gt;은 인터페이스이므로, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;controllerMap&lt;/code&gt;에 저장된 객체들은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ControllerV1&lt;/code&gt;을 구현하는 클래스의 인스턴스이다.
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new MemberFormControllerV1()&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new MemberSaveControllerV1()&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new MemberListControllerV1()&lt;/code&gt;
이러한 구현체들은 모두 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ControllerV1&lt;/code&gt; 타입으로 취급될 수 있습니다. 따라서, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;controllerMap.get()&lt;/code&gt;이 반환하는 값은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ControllerV1&lt;/code&gt; 타입이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.spring.io/spring-framework/docs/3.0.0.M4/spring-framework-reference/html/ch15s02.html&quot;&gt;https://docs.spring.io/spring-framework/docs/3.0.0.M4/spring-framework-reference/html/ch15s02.html&lt;/a&gt;
&lt;a href=&quot;https://docs.spring.io/spring-framework/reference/core/beans/dependencies/factory-collaborators.html&quot;&gt;https://docs.spring.io/spring-framework/reference/core/beans/dependencies/factory-collaborators.html&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 09 Nov 2024 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/framework/2024/11/09/Spring-framework-mvc-01/</link>
        <guid isPermaLink="true">http://localhost:4000/framework/2024/11/09/Spring-framework-mvc-01/</guid>
        
        <category>mvc</category>
        
        
        <category>framework</category>
        
      </item>
    
      <item>
        <title>Java Adv 25 - ThreadPool 전략</title>
        <description>&lt;h2 id=&quot;executor-스레드-풀-관리---고정-풀-전략&quot;&gt;Executor 스레드 풀 관리 - 고정 풀 전략&lt;/h2&gt;

&lt;p&gt;&lt;img width=&quot;654&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/ed2c7546-af1d-4ae1-9521-4af2038d7f1c&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;executor-스레드-풀-관리---캐시-풀-전략&quot;&gt;Executor 스레드 풀 관리 - 캐시 풀 전략&lt;/h2&gt;

&lt;p&gt;&lt;img width=&quot;654&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/8db6e252-07e7-4129-9809-b4d901abdde6&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;newCachedThreadPool()
    &lt;ul&gt;
      &lt;li&gt;기본 스레드를 사용하지 않고, 60초 생존 주기를 가진 초과 스레드만 사용하낟&lt;/li&gt;
      &lt;li&gt;초과 스레드의 수는 제한이 없다.&lt;/li&gt;
      &lt;li&gt;큐에 작접을 저장하지 않는다.
        &lt;ul&gt;
          &lt;li&gt;대신에 생산자 요청을 스레드 풀의 소비자 스레드가 직접 받아서 바로 처리한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;모든 요청이 대기하지 않고 스레드가 바로바로 처리한다. 따라서 빠른 처리가 가능하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img width=&quot;654&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/ef6b16cb-7b5d-4d87-9d58-1704068268d7&quot; /&gt;&lt;/p&gt;

&lt;p&gt;캐시 스레드 풀 전략은 매우 빠르고, 유연한 전략이다.
이 전략은 기본 스레드도 없고, 대기 큐에 작업도 쌓이지 않는다. 
대신에 작업 요청이 오면 초과 스레드로 작업을 바로바로 처리한다.
초과 스레드의 수도 제한이 없기 때문에 CPU, 메모리 자원만 허용한다면 시스템의 자원을 최대로 활용할 수 있다. 
추가로 초과 스레드도 갑자기 증가하고, 요청이 줄어들면 스레드도 점점 줄어든다.&lt;/p&gt;

&lt;h3 id=&quot;주의&quot;&gt;주의&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;이 방식은 작업 수에 맞춰서 스레드 수가 변하기 때문에, 작업의 처리 속도가 빠르고 CPU, 메모리를 유연하게 사용할 수 있다는 장점이 있다. 하지만 상황에 따라서 가장 큰 단점이 되기도 한다.&lt;/li&gt;
  &lt;li&gt;캐시 스레드 전략은 사용자가 점점 증가하면서 스레드 사용량도 함께 늘어나게 된다. 따라서 CPU 메모리의 사용량도 자연스럽게 증가 된다.
    &lt;ul&gt;
      &lt;li&gt;캐시 스레드 풀 전략은 스레드가 무한으로 생성될 수 있기 때문에 너무 많은 스레드가 작업을 처리하면서 시스템 전체가 느려지는 상황을 맞이할 수도 있다.&lt;/li&gt;
      &lt;li&gt;시스템이 멈추는 장애도 발생할 가능성이 있다. 주의해서 사용해야 한다.&lt;/li&gt;
      &lt;li&gt;갑작스럽게 작업량이 늘어나서 작업을 처리해야할 때 사용하는 것이 좋을 것 같다.&lt;/li&gt;
      &lt;li&gt;잠깐의 급한불을 끄는 정도?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;executor-스레드-풀-관리---사용자-정의-풀-전략&quot;&gt;Executor 스레드 풀 관리 - 사용자 정의 풀 전략&lt;/h2&gt;

&lt;h2 id=&quot;상황1---점진적인-사용자-확대&quot;&gt;&lt;strong&gt;상황&lt;/strong&gt;1 - &lt;strong&gt;점진적인&lt;/strong&gt; &lt;strong&gt;사용자&lt;/strong&gt; &lt;strong&gt;확대&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;개발한 서비스가 잘 되어서 사용자가 점점 늘어난다.&lt;/p&gt;

&lt;h2 id=&quot;상황2---갑작스런-요청-증가&quot;&gt;&lt;strong&gt;상황&lt;/strong&gt;2 - &lt;strong&gt;갑작스런&lt;/strong&gt; &lt;strong&gt;요청&lt;/strong&gt; &lt;strong&gt;증가&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;마케팅 팀의 이벤트가 대성공 하면서 갑자기 사용자가 폭증했다.
다음과 같이 세분화된 전략을 사용하면 상황1, 상황2를 모두 어느정도 대응할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;일반&lt;/strong&gt;: 일반적인 상황에는 CPU, 메모리 자원을 예측할 수 있도록 고정 크기의 스레드로 서비스를 안정적으로 운영한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;긴급&lt;/strong&gt;: 사용자의 요청이 갑자기 증가하면 긴급하게 스레드를 추가로 투입해서 작업을 빠르게 처리한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;거절&lt;/strong&gt;: 사용자의 요청이 폭증해서 긴급 대응도 어렵다면 사용자의 요청을 거절한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 방법은 평소에는 안정적으로 운영하다가, 사용자의 요청이 갑자기 증가하면 긴급하게 스레드를 더 투입해서 급한 불을 끄는 방법이다. 
물론 긴급 상황에는 CPU, 메모리 자원을 더 사용하기 때문에 적정 수준을 찾아야 한다. 
일반적으로는 여기까지 대응이 되겠지만, 시스템이 감당할 수 없을 정도로 사용자의 요청이 폭증하면, 
처리 가능한 수준의 사용자 요청만 처리하고 나머지 요청은 거절해야 한다. 
어떤 경우에도 시스템이 다운되는 최악의 상황은 피해야 한다.&lt;/p&gt;

&lt;h2 id=&quot;실무에서-자주-하는-실수&quot;&gt;&lt;strong&gt;실무에서&lt;/strong&gt; &lt;strong&gt;자주&lt;/strong&gt; &lt;strong&gt;하는&lt;/strong&gt; &lt;strong&gt;실수&lt;/strong&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;참고&lt;/strong&gt; - &lt;strong&gt;만약&lt;/strong&gt; &lt;strong&gt;다음과&lt;/strong&gt; &lt;strong&gt;같이&lt;/strong&gt; &lt;strong&gt;설정하면&lt;/strong&gt;?&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ThreadPoolExecutor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;60&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TimeUnit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;SECONDS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;

&lt;span class=&quot;nc&quot;&gt;LinkedBlockingQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;기본 스레드 100개&lt;/li&gt;
  &lt;li&gt;최대 스레드 200개&lt;/li&gt;
  &lt;li&gt;큐 사이즈: 무한대&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이렇게 설정하면 절대로 최대 사이즈 만큼 늘어나지 않는다. 왜냐하면 큐가 가득차야 긴급 상황으로 인지 되는데,
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LinkedBlockingQueue&lt;/code&gt; 를 기본 생성자를 통해 무한대의 사이즈로 사용하게 되면, 큐가 가득찰 수 가 없다. 결국 기본 스레드 100개만으로 무한대의 작업을 처리해야 하는 문제가 발생한다. 실무에서 자주하는 실수 중에 하나이다.&lt;/p&gt;

&lt;h2 id=&quot;executor-예외-정책&quot;&gt;Executor &lt;strong&gt;예외&lt;/strong&gt; &lt;strong&gt;정책&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;생산자 소비자 문제를 실무에서 사용할 때는, 결국 소비자가 처리할 수 없을 정도로 생산 요청이 가득 차면 어떻게 할지를 정해야 한다. 
개발자가 인지할 수 있게 로그도 남겨야 하고, 사용자에게 현재 시스템에 문제가 있다고 알리는 것도 필요하다. 
이런 것을 위해 예외 정책이 필요하다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ThreadPoolExecutor&lt;/code&gt; 에 작업을 요청할 때, 큐도 가득차고, 초과 스레드도 더는 할당할 수 없다면 작업을 거절한다.
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ThreadPoolExecutor&lt;/code&gt; 는 작업을 거절하는 다양한 정책을 제공한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;AbortPolicy: 새로운 작업을 제출할 때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RejectedExecutionException&lt;/code&gt; 을 발생시킨다. 기본 정책이다.&lt;/li&gt;
  &lt;li&gt;DiscardPolicy: 새로운 작업을 조용히 버린다.&lt;/li&gt;
  &lt;li&gt;CallerRunsPolicy: 새로운 작업을 제출한 스레드가 대신해서 직접 작업을 실행한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;사용자&lt;/strong&gt; &lt;strong&gt;정의&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RejectedExecutionHandler&lt;/code&gt; ): 개발자가 직접 정의한 거절 정책을 사용할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;참고로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ThreadPoolExecutor&lt;/code&gt; 를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shutdown()&lt;/code&gt; 하면 이후에 요청하는 작업을 거절하는데, 이때도 같은 정책이 적용된다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;654&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/1c84b96b-6b44-48c1-84a3-66d6cd32434e&quot; /&gt;&lt;/p&gt;

&lt;p&gt;작업이 거절되면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RejectedExecutionException&lt;/code&gt; 을 던진다. 기본적으로 설정되어 있는 정책이다.
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;task1&lt;/code&gt; 은 풀의 스레드가 수행한다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;task2&lt;/code&gt; 를 요청하면 허용 작업을 초과한다. 
따라서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RejectedExecutionException&lt;/code&gt; 이 발생한다. 
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RejectedExecutionException&lt;/code&gt; 예외를 잡아서 작업을 포기하거나, 사용자에게 알리거나, 다시 시도하면 된다. 
이렇게 예외를 잡아서 필요한 코드를 직접 구현해도 되고, 아니면 다음에 설명한 다른 정책들을 사용해도 된다.&lt;/p&gt;

&lt;h2 id=&quot;rejectedexecutionhandler&quot;&gt;RejectedExecutionHandler&lt;/h2&gt;

&lt;p&gt;마지막에 전달한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AbortPolicy&lt;/code&gt; 는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RejectedExecutionHandler&lt;/code&gt; 의 구현체이다.
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ThreadPoolExecutor&lt;/code&gt; 생성자는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RejectedExecutionHandler&lt;/code&gt; 의 구현체를 전달 받는다.&lt;/p&gt;

&lt;h2 id=&quot;discardpolicy&quot;&gt;DiscardPolicy&lt;/h2&gt;

&lt;p&gt;&lt;img width=&quot;654&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/1d5a4d45-84d3-45e3-a064-3d33d1f2bf28&quot; /&gt;&lt;/p&gt;

&lt;p&gt;거절된 작업을 무시하고 아무런 예외도 발생시키지 않는다. 
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ThreadPoolExecutor&lt;/code&gt; 생성자 마지막에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new ThreadPoolExecutor.DiscardPolicy()&lt;/code&gt; 를 제공하면 된다.
코드를 확인해보면 비어있는 것을 확인할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;callerrunspolicy&quot;&gt;CallerRunsPolicy&lt;/h2&gt;

&lt;p&gt;&lt;img width=&quot;654&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/79548339-d306-461b-b68e-4eaadaee4c02&quot; /&gt;
&lt;img width=&quot;654&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/aafc1e76-ac58-4b1d-bcf6-f11365c87b2d&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;task2&lt;/code&gt; 는 스레드 풀에 보관할 큐도 없고, 작업할 스레드가 없다. 거절해야 한다. 
이때 작업을 거절하는 대신에, 작업을 요청한 스레드에 대신 일을 시킨다.
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;task2&lt;/code&gt; 의 작업을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt; 스레드가 수행하는 것을 확인할 수 있다.
이 정책의 특징은 생산자 스레드가 소비자 대신 일을 수행하는 것도 있지만, 
생산자 스레드가 대신 일을 수행하는 덕분에 작업의 생산 자체가 느려진다는 점이다. 
덕분에 작업의 생산 속도가 너무 빠르다면, 생산 속도를 조절할 수 있다. 
원래대로 하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt; 스레드가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;task1&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;task2&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;task3&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;task4&lt;/code&gt; 를 연속해서 바로 생산해야 한다.
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CallerRunsPolicy&lt;/code&gt; 정책 덕분에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt; 스레드는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;task2&lt;/code&gt; 를 본인이 직접 완료하고 나서야 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;task3&lt;/code&gt; 을 생산할 수 있다. 
결과적으로 생산 속도가 조절되었다.&lt;/p&gt;

&lt;h2 id=&quot;가장-좋은-최적화는-최적화하지-않는-것이다&quot;&gt;가장 좋은 최적화는 최적화하지 않는 것이다&lt;/h2&gt;

&lt;p&gt;많은 개발자가 미래에 발생하지 않을 일 때문에 코드를 최적화하는 경우가 많다. 예를 들어서 초기 서비스이고, 아직 사용자가 많을지 예측이 되지 않는 상황인데, 코드 최적화에 너무 많은 시간을 사용할 수 있다. 이것은 사용자는 얼마 없는데 매우 비싼 서버를 구매하는 것과 같다. 물론 이 이야기가 극단적으로 최적화를 하지 말자는 말이 아니다. 예를 들어서 A와 관련된 기능을 매우 많이 최적화 했는데, 사용자가 없어서 결국 버리게 되는 경우도 있다. 반면에 별로 신경쓰지 않은 B와 관련된 기능에 사용자가 많이 늘어날 수도 있다. 
중요한 것은 예측 불가능한 너무 먼 미래 보다는 현재 상황에 맞는 최적화가 필요하다는 점이다.
시스템의 상황을 잘 모니터링 하고 있다가, 최적화가 필요한 부분들이 발생하면, 그때 필요한 부분들을 개선하는 것이다.
우리가 만든 서비스가 잘 되어서 많은 요청이 들어오면 좋겠지만, 대부분의 서비스는 트래픽이 어느정도 예측 가능하다. 
그리고 성장하는 서비스라도 어느정도 성장이 예측 가능하다. 
그래서 일반적인 상황이라면 고정 스레드 풀 전략이나, 캐시 스레드 풀 전략을 사용하면 충분하다. 
한번에 처리할 수 있는 수를 제안하고 안정적으로 처리하고 싶다면 고정 풀 전략을 선택하고, 
사용자의 요청을 빠르게 대응하고 싶다면 캐시 스레드 풀 전략을 사용하면 된다. 
물론 자원만 충분하다면 고정 풀 전략을 선택하면서 풀의 수를 많이 늘려서 사용자의 요청도 빠르게 대응하면서 안정적인 서비스 운영도 가능하다. 
그러다가 일반적인 상황을 벋어날 정도로 서비스가 잘 운영되면 그때 더 나은 최적화 방법을 선택하면 된다.&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;p&gt;김영한님의 자바 강의&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/essential/concurrency/sync.html&quot;&gt;https://docs.oracle.com/javase/tutorial/essential/concurrency/sync.html&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Thu, 07 Nov 2024 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/language/2024/11/07/Java-Adv-25/</link>
        <guid isPermaLink="true">http://localhost:4000/language/2024/11/07/Java-Adv-25/</guid>
        
        <category>java</category>
        
        
        <category>language</category>
        
      </item>
    
      <item>
        <title>Java Adv 24 - ExecutorService</title>
        <description>&lt;h2 id=&quot;executorservice&quot;&gt;ExecutorService&lt;/h2&gt;

&lt;p&gt;&lt;img width=&quot;654&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/cbeb4629-5732-4f1f-bc17-6e5cedf23212&quot; /&gt;
&lt;img width=&quot;654&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/80b6f85f-a1e5-4c76-8782-b568d978ca05&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ExecutorService&lt;/code&gt;를 사용하여 여러 작업을 비동기로 실행하고, 스레드 풀을 안전하게 종료(shutdown)하는 과정을 보여줍니다. 특히, 작업이 끝나지 않거나 
대기 중인 작업이 있을 경우 이를 강제로 종료하는 로직이다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Executors.newFixedThreadPool(2)&lt;/code&gt;는 최대 2개의 스레드를 유지하는 고정 크기의 스레드 풀을 생성한다.&lt;/li&gt;
  &lt;li&gt;동시에 2개의 작업만 실행되며, 초과하는 작업은 내부 큐에 대기한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img width=&quot;654&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/00dbfd58-2973-49a9-a449-eb248c2f8493&quot; /&gt;
&lt;img width=&quot;654&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/498d651e-0084-485a-8010-0c2c956f34da&quot; /&gt;
&lt;img width=&quot;654&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/2ae16ead-34f3-4b6f-9c70-55aafacd5ae9&quot; /&gt;
&lt;img width=&quot;654&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/9fb04f64-ffc2-4d2a-8986-2bf6cf378eca&quot; /&gt;&lt;/p&gt;

&lt;p&gt;corePoolsize 2개 maximumPoolSize도 4개 총 6개를 초과하면 task 7개부터 RejectedException이 발생한다. 
큐에도 작업이 다차면 이때 maximum(초과 스레드)까지 늘리게 된다.
초과 스레드는 긴급한 상황에서 쓰이고 긴급한 상황이 끝나면 기다리다가 긴급한 상황이 종료되면 스레드를 제거해서 정상적으로 돌아온다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;654&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/379d45a2-bab4-4538-93e5-605c325fb349&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Executors에는 초과 스레드인 3을 만든다.&lt;/li&gt;
  &lt;li&gt;작업을 처리하기 위해 스레드를 하나 생성했기 때문에 작업을 큐에 넣을 필요 없이, 해당 스레드가 바로 작업을 처리한다. 따라서 task5가 task3, task4 보다 먼저 처리된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;p&gt;김영한님의 자바 강의&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/essential/concurrency/sync.html&quot;&gt;https://docs.oracle.com/javase/tutorial/essential/concurrency/sync.html&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Tue, 05 Nov 2024 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/language/2024/11/05/Java-Adv-24/</link>
        <guid isPermaLink="true">http://localhost:4000/language/2024/11/05/Java-Adv-24/</guid>
        
        <category>java</category>
        
        
        <category>language</category>
        
      </item>
    
      <item>
        <title>Nginx SpringBoot</title>
        <description>&lt;p&gt;사내에서 서비스 개발을 진행하게 될 환경을 구축하는 것을 담당하게 되었다.
항상 주어진 환경내에서만 세팅을 하다가 직접 세팅을 하게 되니 얻는 것이 많아서 글을 작성하게 되었다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;654&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/05efb4bc-8fc1-4384-9a4e-cc0bdda90797&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Nginx 기반의 Springboot 서버를 띄우는 것이 이번 환경 구축의 핵심이다.&lt;/p&gt;

&lt;h2 id=&quot;docker-network-설정&quot;&gt;Docker network 설정&lt;/h2&gt;

&lt;p&gt;&lt;img width=&quot;654&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/9de2ffc1-5787-4d5f-8f40-8e539af8de4a&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Docker 네트워크가 중요한 이유는 &lt;strong&gt;컨테이너 간의 통신&lt;/strong&gt;을 가능하게 하기 위해서이다. 
Docker에서 각 컨테이너는 기본적으로 &lt;strong&gt;독립된 네트워크 환경&lt;/strong&gt;을 가지고 있어, 
서로 다른 네트워크에 있으면 컨테이너 간에 직접적으로 통신할 수 없다. 
Docker 네트워크를 사용하면 동일한 네트워크 내에 있는 컨테이너들끼리는 서로 쉽게 통신할 수 있다.
따라서 trusted-net 이라는 네트워크를 하나 만들어 두고 컨테이너들을 매핑시켜 주었다.&lt;/p&gt;

&lt;h2 id=&quot;nginxconf-파일-수정-과정&quot;&gt;Nginx.conf 파일 수정, 과정&lt;/h2&gt;

&lt;p&gt;처음 해보는 것이라 이게 굉장히 애를 많이 먹었는데 일단 과정을 살펴보자&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker &lt;span class=&quot;nb&quot;&gt;exec&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-it&lt;/span&gt; nginx-proxy-server /bin/bash
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;먼저 Container안에 접속을 해주고&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; /etc/nginx/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;/etc/nginx에 들어가서 default.conf를 확인한다.
그리고 이제 nginx.conf 파일을 수정해야 한다.&lt;/p&gt;

&lt;h2 id=&quot;nginxconf&quot;&gt;nginx.conf&lt;/h2&gt;

&lt;p&gt;&lt;img width=&quot;654&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/e52dd8d9-f261-434c-a525-9f3746372d80&quot; /&gt;&lt;/p&gt;

&lt;p&gt;포트를 다 내부포트로 변경하고, default로 설정되어 있는 include경로를 제거한다.
처음에 이것을 제거해주지 않아서 8083으로 입력했을 때 boot가 나오지 않고 
include에 포함되어 있는 conf파일이 나와서 아래의 경로로 설정한 서버가 나오지 않았었다. 
include 경로를 제거해줘야 한다.
이제 8083포트를 입력해주면 해당 서버가 제대로 나오게 된다.&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://velog.io/@18k7102dy/Docker-Spring-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EB%A5%BC-Docker%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%B4%EC%84%9C-%EB%B0%B0%ED%8F%AC%ED%95%B4%EB%B4%85%EC%8B%9C%EB%8B%A4&quot;&gt;https://velog.io/@18k7102dy/Docker-Spring-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EB%A5%BC-Docker%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%B4%EC%84%9C-%EB%B0%B0%ED%8F%AC%ED%95%B4%EB%B4%85%EC%8B%9C%EB%8B%A4&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Sun, 03 Nov 2024 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/devops/2024/11/03/Devops-Docker-03/</link>
        <guid isPermaLink="true">http://localhost:4000/devops/2024/11/03/Devops-Docker-03/</guid>
        
        <category>docker</category>
        
        
        <category>devops</category>
        
      </item>
    
      <item>
        <title>Spring Profile</title>
        <description>&lt;h2 id=&quot;spring-profile&quot;&gt;Spring Profile&lt;/h2&gt;

&lt;p&gt;입사하고 얼마 지나지 않아 서비스를 운영하게 되는데 Spring profile에 대해서 처음알게 되었다.
항상 하나의 개발 환경세팅만 하다보니 각 환경에 대해서 분리해서 개발을 진행하게 되는지 처음 알았다.
우선 Spring Profile이란 Spring 애플리케이션에서 환경에 따라 다르게 동작하도록 설정을 분리하는 기능이다. 
이를 통해 개발, 테스트, 프로덕션 등 여러 환경에 맞게 설정을 관리할 수 있다. Spring Profile을 사용하면, 
각 환경에 특화된 설정을 선언하고, 애플리케이션이 실행될 때 해당 프로파일에 맞는 설정을 자동으로 로드할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;왜-중요할까&quot;&gt;왜 중요할까?&lt;/h2&gt;

&lt;p&gt;환경에 맞는 설정을 자동으로 적용한다. 예를 들어, application-dev.properties 파일과 application-prod.properties 파일을 두고, 
개발 환경에서는 개발용 데이터베이스 설정을, 운영 환경에서는 실제 운영 데이터베이스 설정을 자동으로 읽어올 수 있다.
환경에 따른 Bean 설정: @Profile 어노테이션을 사용하여 특정 환경에서만 활성화되는 Bean을 정의할 수 있다. 
예를 들어, 개발 환경에서는 디버깅용으로 로깅 레벨을 높게 설정하고, 운영 환경에서는 성능을 고려한 로깅 설정을 할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;576&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/0065b293-deb8-455d-8a58-5eeee16be926&quot; /&gt;
&lt;img width=&quot;590&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/8c8fd2d2-6a47-4214-8c42-d825c865e839&quot; /&gt;&lt;/p&gt;

&lt;p&gt;각 프로파일에 따른 설정&lt;/p&gt;

&lt;p&gt;local, prod, dev 세 가지 프로파일로 나뉘어져 있다. 각 프로파일에 대해 다른 설정을 적용할 수 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;local: 개발자가 로컬 환경에서 실행할 때 사용하는 프로파일로, 로컬 데이터베이스나 디버깅 설정 등을 포함할 수 있다.&lt;/li&gt;
  &lt;li&gt;prod: 운영 환경에서 사용하는 프로파일로, 실제 서비스에 배포되는 설정을 포함한다. 보통 보안이나 성능 관련 설정이 중요하다.&lt;/li&gt;
  &lt;li&gt;dev: 개발 환경에서 사용하는 프로파일로, 개발 중에 사용되는 설정이 포함한다. 로깅이나 디버깅을 위해 다양한 설정을 추가할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.spring.io/spring-boot/docs/1.2.0.M1/reference/html/boot-features-profiles.html&quot;&gt;https://docs.spring.io/spring-boot/docs/1.2.0.M1/reference/html/boot-features-profiles.html&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 01 Nov 2024 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/framework/2024/11/01/Spring-06/</link>
        <guid isPermaLink="true">http://localhost:4000/framework/2024/11/01/Spring-06/</guid>
        
        <category>spring</category>
        
        
        <category>framework</category>
        
      </item>
    
      <item>
        <title>Java Adv 23 - Executor framework</title>
        <description>&lt;h2 id=&quot;callable&quot;&gt;Callable&lt;/h2&gt;

&lt;p&gt;&lt;img width=&quot;654&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/ad0cac70-aafe-4107-8856-3b28743de4dd&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java.util.concurrent.Executors&lt;/code&gt; 가 제공하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;newFixedThreadPool(size)&lt;/code&gt; 을 사용하면 편리하게
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ExecutorService&lt;/code&gt; 를 생성할 수 있다.&lt;/p&gt;

&lt;p&gt;기존 코드&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;ExecutorService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;es&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ThreadPoolExecutor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TimeUnit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;MILLISECONDS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;

&lt;span class=&quot;nc&quot;&gt;LinkedBlockingQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;());&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;편의 코드&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;ExecutorService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;es&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Executors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;newFixedThreadPool&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MyCallable&lt;/code&gt;은 숫자를 반환하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Callable&lt;/code&gt; 인터페이스를 구현한 클래스이다. 
이 인터페이스를 활용하면 작업 완료 후 결과를 반환할 수 있다는 점에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Runnable&lt;/code&gt;과 차이가 있다. 
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Runnable&lt;/code&gt;은 작업 결과를 직접 반환할 수 없기 때문에 결과를 저장할 별도의 필드를 만들어야 하지만, 
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Callable&lt;/code&gt;은 결과를 반환하는 기능을 제공하기 때문에 필드 없이 구현이 가능하다.
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ExecutorService&lt;/code&gt;는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;submit()&lt;/code&gt; 메서드를 통해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Callable&lt;/code&gt; 작업을 스레드 풀에 전달할 수 있게 한다. 
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;submit()&lt;/code&gt; 메서드는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt;라는 특별한 인터페이스를 반환하며, 이를 통해 비동기적으로 작업 결과를 확인하거나 가져올 수 있다. 
예를 들어, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MyCallable&lt;/code&gt; 인스턴스를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;submit()&lt;/code&gt; 메서드에 전달하면 해당 작업은 블로킹 큐에 추가되고, 
스레드 풀의 스레드 중 하나가 이를 실행한다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;Future&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;future&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;es&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;submit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MyCallable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;작업의 처리 결과는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt; 객체를 통해 얻을 수 있다. 
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;get()&lt;/code&gt; 메서드를 호출하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MyCallable&lt;/code&gt;의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;call()&lt;/code&gt; 메서드가 반환한 결과를 받을 수 있으며, 
작업이 완료될 때까지 호출부가 블로킹된다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;future&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 과정에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;get()&lt;/code&gt; 메서드는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;InterruptedException&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ExecutionException&lt;/code&gt;이라는 체크 예외를 던질 수 있다. 
예외는 필요에 따라 적절히 처리하거나 호출부로 전달할 수 있다.
Executor 프레임워크의 가장 큰 강점은 스레드를 생성하거나 제어하는 복잡한 작업을 하지 않아도 멀티스레드 환경을 쉽게 활용할 수 있다는 점이다. 
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Callable&lt;/code&gt;을 사용하면 작업 결과를 반환받아야 하는 상황에서도 편리하며, 
개발자는 단순히 작업을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ExecutorService&lt;/code&gt;에 제출하고 결과를 받아 사용하는 방식으로 구현할 수 있다. 
복잡한 멀티스레드 작업을 간단하게 처리할 수 있도록 해주는 것이 Executor 프레임워크의 핵심적인 장점이다.&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;p&gt;김영한님의 자바 강의&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/essential/concurrency/sync.html&quot;&gt;https://docs.oracle.com/javase/tutorial/essential/concurrency/sync.html&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 28 Oct 2024 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/language/2024/10/28/Java-Adv-23/</link>
        <guid isPermaLink="true">http://localhost:4000/language/2024/10/28/Java-Adv-23/</guid>
        
        <category>java</category>
        
        
        <category>language</category>
        
      </item>
    
      <item>
        <title>소풍</title>
        <description>&lt;h2 id=&quot;소풍&quot;&gt;소풍&lt;/h2&gt;

&lt;p&gt;각 학생들의 쌍에 대해 이들이 서로 친구인지 여부가 주어질 때, 학생들을 짝지을 수 있는 방법의 수를 계산하는 프로그램을
작성하시오. 짝이 되는 학생들이 일부만 다르더라도 다른 방법이라고 가정합니다.&lt;/p&gt;

&lt;p&gt;사실 위의 문제는 백준, 프로그래머스 문제가 아닌, 알고리즘 종만북이라는 책의 내용을 토대로 문제를 풀이하게 되었다.
계속해서 문제를 양치기 하는 것보다 문제를 어떻게 해결하는가에 중심을 둬서 배우고 싶어서 책을 꺼냈다.&lt;/p&gt;

&lt;h2 id=&quot;접근&quot;&gt;접근&lt;/h2&gt;

&lt;p&gt;책에서는 이 문제를 모든 가능한 조합의 수를 계산하는 방법은 완전 탐색과 재귀호출을 이용하여 문제를 해결하였다.
재귀호출로 문제를 풀면 고려해야 할 것들이 백트래킹과, 기저사례이다. 사실 위의 두 지식도 알고만 있지 제대로 적절하게
활용하는 법을 자세히는 알지 못해서 이번기회에 제대로 배워볼까 한다.
우선 문제의 풀이는 짝을 찾지 못한 학생들의 명단이 주어질 때 친구끼리 둘씩 짝짓는 경우의 수를 계산하라가 된다.
명단에서 서로 친구인 두 학생을 찾아 이들을 짝지어 주고나면 남는 학생들을 짝지어 주는 문제도 원래 문제와 같은 형태가 된다.&lt;/p&gt;

&lt;h2 id=&quot;코드&quot;&gt;코드&lt;/h2&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt;&lt;span class=&quot;cpf&quot;&gt;&amp;lt;bits/stdc++.h&amp;gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;areFriends&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;countPairings&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;taken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]){&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;firstFree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;taken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]){&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;firstFree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;firstFree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pairWith&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;firstFree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pairWith&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pairWith&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;taken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pairWith&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;areFriends&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;firstFree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pairWith&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;taken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;firstFree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;taken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pairWith&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;countPairings&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;taken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;taken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;firstFree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;taken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pairWith&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fill&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;areFriends&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;areFriends&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;cin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;areFriends&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;areFriends&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;taken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;countPairings&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;taken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'\n'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;기저사례-종료조건&quot;&gt;기저사례 종료조건&lt;/h2&gt;

&lt;p&gt;기저사례로 재귀호출을 종료시킬 때 0을 반환해야할까? 1을 반환해야할까? 어떤 의미가 담겨있을까 고민을 했던 적이 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1을 반환: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;을 반환하는 경우는 일반적으로 “성공” 또는 “올바른 결과”를 의미한다.
    &lt;ul&gt;
      &lt;li&gt;예를 들어, “모든 학생이 짝이 지어졌다는” 성공적인 조건이 만족되었을 때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;을 반환하는 것은 논리적으로 자연스럽다.&lt;/li&gt;
      &lt;li&gt;이 값은 함수가 정상적으로 종료되었음을 나타낸다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;0을 반환: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;을 반환하는 경우는 보통 “실패” 또는 “조건이 만족되지 않음”을 의미한다.
    &lt;ul&gt;
      &lt;li&gt;만약 기저 사례에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;을 반환하면 “성공적인 종료”를 의미하기 어려울 수 있다.&lt;/li&gt;
      &lt;li&gt;따라서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;을 반환하면, 이 부분이 “짝을 모두 지을 수 없었다”는 의미로 해석될 수 있다.
&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-1&lt;/code&gt;을 사용하는 이유&lt;/strong&gt;: 보통 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-1&lt;/code&gt;은 “유효하지 않은 인덱스”를 나타내거나, 배열이나 리스트에서 찾을 수 없는 값을 표현할 때 사용된다. 즉, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;firstFree == -1&lt;/code&gt;이 의미하는 바는 “더 이상 짝을 지을 학생이 없다”는 것이다. 일반적으로, 배열의 인덱스나 리스트에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-1&lt;/code&gt;은 “유효한 값이 없다”는 뜻으로 자주 사용되기 때문에 이를 이용한 표현은 매우 직관적이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;짝지어주기-반복문&quot;&gt;짝지어주기 반복문&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;firstFree&lt;/code&gt;는 아직 짝을 짓지 않은 첫 번째 학생을 가리킨다. 
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pairWith&lt;/code&gt;는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;firstFree&lt;/code&gt; 이후의 학생들 중에서 짝을 지을 수 있는 학생을 차례대로 탐색한다. 
반복문을 통해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pairWith&lt;/code&gt;가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;firstFree&lt;/code&gt;와 짝을 지을 수 있는지 확인한다. 
(즉, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pairWith&lt;/code&gt;가 짝이 안 지어졌고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;firstFree&lt;/code&gt;와 친구 관계인지 확인) 
&lt;strong&gt;짝을 지을 수 있으면&lt;/strong&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;firstFree&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pairWith&lt;/code&gt;를 짝지은 후, &lt;strong&gt;재귀적으로 나머지 학생들을 짝을 지어 나간다.&lt;/strong&gt; 
재귀 호출이 끝나면 &lt;strong&gt;백트래킹&lt;/strong&gt;을 통해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;firstFree&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pairWith&lt;/code&gt;의 짝을 다시 풀고, 다른 가능성도 탐색한다.&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;p&gt;나의 뇌&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://book.algospot.com/&quot;&gt;https://book.algospot.com/&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 27 Oct 2024 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/cs/2024/10/27/Algorithm-22/</link>
        <guid isPermaLink="true">http://localhost:4000/cs/2024/10/27/Algorithm-22/</guid>
        
        <category>Algorithm</category>
        
        
        <category>cs</category>
        
      </item>
    
      <item>
        <title>Java Adv 22 - Executor framework</title>
        <description>&lt;h2 id=&quot;executor-&quot;&gt;Executor ?&lt;/h2&gt;

&lt;p&gt;자바의 Excutor 프레임워크는 멀티스레딩 및 병렬처리를 쉽게 사용할 수 있도록 돕는 기능의 모음이다.
이 프레임워크는 작업 실행의 관리 및 스레드 풀 관리를 효율적으로 처리해서 개발자가 직접 스레드를 생성하고 관리하는 복잡함을 줄여준다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;701&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/36cca863-d732-4b84-b54f-7a679a910d9f&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;pool: 스레드 풀에서 관리되는 스레드의 숫자&lt;/li&gt;
  &lt;li&gt;active: 작업을 수행중인 스레드의 숫자&lt;/li&gt;
  &lt;li&gt;queuedTask: 큐에 대기중인 작업의 숫자&lt;/li&gt;
  &lt;li&gt;completedTask: 완료된 작업의 숫자&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;16:21:25.327 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;     main] &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; 초기 상태 &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; 
16:21:25.337 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;     main] &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;pool&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0, &lt;span class=&quot;nv&quot;&gt;active&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0, &lt;span class=&quot;nv&quot;&gt;queuedTasks&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0, &lt;span class=&quot;nv&quot;&gt;completedTask&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0]
16:21:25.338 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;     main] &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; 작업 수행 중 &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; 
16:21:25.338 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;     main] &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;pool&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;2, &lt;span class=&quot;nv&quot;&gt;active&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;2, &lt;span class=&quot;nv&quot;&gt;queuedTasks&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;2, &lt;span class=&quot;nv&quot;&gt;completedTask&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0]
16:21:25.338 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;pool-1-thread-2] taskB 시작
16:21:25.338 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;pool-1-thread-1] taskA 시작
16:21:26.343 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;pool-1-thread-2] taskB 완료
16:21:26.343 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;pool-1-thread-1] taskA 완료
16:21:26.344 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;pool-1-thread-2] taskC 시작
16:21:26.344 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;pool-1-thread-1] taskD 시작
16:21:27.348 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;pool-1-thread-2] taskC 완료
16:21:27.349 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;pool-1-thread-1] taskD 완료
16:21:28.344 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;     main] &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; 작업 수행 완료 &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; 
16:21:28.345 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;     main] &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;pool&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;2, &lt;span class=&quot;nv&quot;&gt;active&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0, &lt;span class=&quot;nv&quot;&gt;queuedTasks&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0, &lt;span class=&quot;nv&quot;&gt;completedTask&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;4]
16:21:28.347 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;     main] &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; shutdown &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; 
16:21:28.347 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;     main] &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;pool&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0, &lt;span class=&quot;nv&quot;&gt;active&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0, &lt;span class=&quot;nv&quot;&gt;queuedTasks&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0, &lt;span class=&quot;nv&quot;&gt;completedTask&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;4]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;threadpoolexecutor의-구성-요소-및-동작-원리&quot;&gt;ThreadPoolExecutor의 구성 요소 및 동작 원리&lt;/h2&gt;

&lt;h2 id=&quot;1-구성-요소&quot;&gt;1. &lt;strong&gt;구성 요소&lt;/strong&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;스레드 풀&lt;/strong&gt;: 스레드를 생성하고 관리하는 역할을 한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;BlockingQueue&lt;/strong&gt;: 작업을 보관하며, 생산자-소비자 문제를 해결하기 위해 단순 큐 대신 사용된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-생산자와-소비자&quot;&gt;2. &lt;strong&gt;생산자와 소비자&lt;/strong&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;생산자&lt;/strong&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt; 스레드가 생산자로, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;es.execute(작업)&lt;/code&gt; 호출 시 작업이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BlockingQueue&lt;/code&gt;에 저장된다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;소비자&lt;/strong&gt;: 스레드 풀 내의 스레드가 소비자로, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BlockingQueue&lt;/code&gt;에서 작업을 꺼내어 처리한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3-threadpoolexecutor-생성자-주요-속성&quot;&gt;3. &lt;strong&gt;ThreadPoolExecutor 생성자 주요 속성&lt;/strong&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;corePoolSize: 기본적으로 유지되는 스레드 수.&lt;/li&gt;
  &lt;li&gt;maximumPoolSize: 허용되는 최대 스레드 수.&lt;/li&gt;
  &lt;li&gt;keepAliveTime 및 TimeUnit unit: 기본 스레드 수를 초과한 스레드가 유지되는 시간. 시간이 초과되면 스레드가 제거된다.&lt;/li&gt;
  &lt;li&gt;BlockingQueue workQueue: 작업을 저장하는 블로킹 큐.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4-구체적인-예&quot;&gt;4. 구체적인 예&lt;/h2&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ThreadPoolExecutor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TimeUnit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;MILLISECONDS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LinkedBlockingQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;());&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;corePoolSize=2, maximumPoolSize=2: 스레드 풀에서 스레드 수는 고정(2개)이다.&lt;/li&gt;
  &lt;li&gt;keepAliveTime=0 및 TimeUnit.MILLISECONDS: 초과 스레드가 제거될 시간이 없으므로 의미 없음.&lt;/li&gt;
  &lt;li&gt;LinkedBlockingQueue: 작업을 무한정 저장할 수 있는 블로킹 큐를 사용.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;참고로 당연한 이야기지만 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt; 스레드는 작업을 전달하고 기다리지 않는다. 전달한 작업은 다른 스레드
가 실행할 것이다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt; 스레드는 작업을 큐에 보관까지만 하고 바로 다음 코드를 수행한다.
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;taskA~D&lt;/code&gt; 요청이 블로킹 큐에 들어온다.
최초의 작업이 들어오면 이때 작업을 처리하기 위해 스레드를 만든다.
참고로 스레드 풀에 스레드를 미리 만들어두지는 않는다.
작업이 들어올 때 마다 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;corePoolSize&lt;/code&gt; 의 크기 까지 스레드를 만든다.
예를 들어서 최초 작업인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;taskA&lt;/code&gt; 가 들어오는 시점에 스레드1을 생성하고, 
다음 작업인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;taskB&lt;/code&gt; 가 들어오는 시점에 스레드2를 생성한다. 
이런 방식으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;corePoolSize&lt;/code&gt; 에 지정한 수 만큼 스레드를 스레드 풀에 만든다. 
여기서는 2를 설정했으므로 2개까지 만든다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;corePoolSize&lt;/code&gt; 까지 스레드가 생성되고 나면, 
이후에는 스레드를 생성하지 않고 앞서 만든 스레드를 재b사용한다.&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;p&gt;김영한님의 자바 강의&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/essential/concurrency/sync.html&quot;&gt;https://docs.oracle.com/javase/tutorial/essential/concurrency/sync.html&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Sat, 26 Oct 2024 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/language/2024/10/26/Java-Adv-22/</link>
        <guid isPermaLink="true">http://localhost:4000/language/2024/10/26/Java-Adv-22/</guid>
        
        <category>java</category>
        
        
        <category>language</category>
        
      </item>
    
      <item>
        <title>Java Adv 21 - 스레드를 직접 사용할 때의 문제점</title>
        <description>&lt;h2 id=&quot;스레드-생성-비용으로-인한-성능-문제&quot;&gt;스레드 생성 비용으로 인한 성능 문제&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;메모리 할당
    &lt;ul&gt;
      &lt;li&gt;각 스레드는 자신만의 호출 스택(call stack)을 가지고 있다. 이 호출 스택은 스레드가 실행되는 동안 사용하는 메모리 공간이다.&lt;/li&gt;
      &lt;li&gt;스레드를 생성할 땐 이 호출 스택을 위한 메모리를 할당해야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;운영체제 자원 사용
    &lt;ul&gt;
      &lt;li&gt;스레드를 생성하는 작업은 운영체제 커널 수준에서 일어난다.
        &lt;ul&gt;
          &lt;li&gt;스레드를 관리하고 실행순서를 조정해야 한다.&lt;/li&gt;
          &lt;li&gt;참고로 스레드 하나는 보통 1MB 이상의 메모리를 사용한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;스레드를 생성하는 작업은 생각보다 무겁다. 단순히 자바 객체를 하나 생성하는 것과는 비교할 수 없을 정도로 큰 작업이다. 예를 들어서 어떤 작업 하나를 수행할 때 마다 스레드를 각각 생성하고 실행한다면, 스레드의 생성 비용 때문에 많은 시간이 소모 된다. 아주 가벼운 작업이라면, 작업의 실행 시간보다 스레드의 생성 시간이 더 오래 걸릴 수도 있다. 이러한 문제를 해결하기 위해서 이미 생성한 스레드를 재활용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;스레드-관리-문제&quot;&gt;스레드 관리 문제&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;서버의 CPU, 메모리 자원은 한정되어 있기 때문에, 스레드는 무한하게 만들 수 없다.&lt;/li&gt;
  &lt;li&gt;예를 들어서 서버의 사용자의 주문을 처리하는 서비스라고 가정하자. 그리고 사용자는 갑자기 몰려들 수 있다. 평소에는 100개 정도의 스레드 정도면 충분했는데, 갑자기 10000개의 스레드가 필요한 상황이 된다면, CPU 메모리 자원이 버틸 수 없을 것이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;runnable-인터페이스의-불편함&quot;&gt;Runnable 인터페이스의 불편함&lt;/h2&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Runnable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;반환 값이 없다: run() 메서드는 반환값을 가지지 않는다. 따라서 실행 결과의 값을 얻으려면 별도의 메커니즘을 사용해야 한다. 쉽게 이야기해서 스레드의 실행 결과를 직접 받을 수 없다. 스레드가 실행한 결과를 멤버 변수에다가 넣고, join() 등을 사용해서 스레드가 종료되기를 기다린 다음에 멤버 변수의 보관한 값을 받아야 한다.&lt;/li&gt;
  &lt;li&gt;예외 처리: run() 메서드는 체크 예외(checked exception)를 던질 수 없다. 체크 예외의 처리는 메서드 내부에서 처리해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;thread.collection.simple.list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SumTaskExample&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;calculateSum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SumTask&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Runnable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
            &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;SumTask&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sumTask&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SumTask&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sumTask&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getResult&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;SumTaskExample&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sumTaskExample&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SumTaskExample&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sumTaskExample&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;calculateSum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;sumTaskExample = &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sumTaskExample&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getResult&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 보통은 이렇게 결과값을 리턴받는다.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;thread-pool&quot;&gt;Thread pool&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;스레드를 관리하고 생성하는 스레드 풀이 필요하다.&lt;/li&gt;
  &lt;li&gt;스레드를 관리하는 스레드 풀(스레드가 모여서 대기하는 수영장 풀 같은 개념)에 스레드를 필요한 만큼 미리 만들어 둔다.&lt;/li&gt;
  &lt;li&gt;스레드는 스레드 풀에서 대기하며 쉰다.&lt;/li&gt;
  &lt;li&gt;작업 요청이 온다.&lt;/li&gt;
  &lt;li&gt;스레드 플에서 이미 만들어진 스레드를 꺼낸다.&lt;/li&gt;
  &lt;li&gt;조회한 스레드1로 작업을 처리한다.&lt;/li&gt;
  &lt;li&gt;스레드 1은 작업을 완료한다.&lt;/li&gt;
  &lt;li&gt;작업을 완료한 스레드는 종료하는게 아니라, 다시 스레드 풀에 반납한다. 스레드 1은 이후로 다시 재사용이 될 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;excutor&quot;&gt;Excutor&lt;/h2&gt;

&lt;p&gt;사실 스레드 풀이라는 것이 별것이 아니다. 그냥 컬렉션에 스레드를 보관하고 재사용할 수 있게 하면 된다. 하지만 스레드 풀에 있는 스레드는 처리할 작업이 없다면, 대기(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WAITING&lt;/code&gt; ) 상태로 관리해야 하고, 작업 요청이 오면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RUNNABLE&lt;/code&gt;상태로 변경해야 한다. 막상 구현하려고 하면 생각보다 매우 복잡하다는 사실을 알게될 것이다. 여기에 생산자 소비자 문제까지 겹친다. 잘 생각해보면 어떤 생산자가 작업(task)를 만들 것이고, 우리의 스레드 풀에 있는 스레드가 소비자가 되는 것이다.
이런 문제를 한방에 해결해주는 것이 바로 자바가 제공하는 Executor 프레임워크다.
Executor 프레임워크는 스레드 풀, 스레드 관리, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Runnable&lt;/code&gt; 의 문제점은 물론이고, 생산자 소비자 문제까지 한방에 해결해주는 자바 멀티스레드 최고의 도구이다. 지금까지 우리가 배운 멀티스레드 기술의 총 집합이 여기에 들어있다.
참고로 앞서 설명한 이유와 같이 스레드를 사용할 때는 생각보다 고려해야 할 일이 많다. 그래서 실무에서는 스레드를 직접 하나하나 생성해서 사용하는 일이 드물다. 대신에 지금부터 설명할 Executor 프레임워크를 주로 사용하는데, 이 기술을 사용하면 매우 편리하게 멀티스레드 프로그래밍을 할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;p&gt;김영한님의 자바 강의&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/essential/concurrency/sync.html&quot;&gt;https://docs.oracle.com/javase/tutorial/essential/concurrency/sync.html&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Fri, 25 Oct 2024 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/language/2024/10/25/Java-Adv-21/</link>
        <guid isPermaLink="true">http://localhost:4000/language/2024/10/25/Java-Adv-21/</guid>
        
        <category>java</category>
        
        
        <category>language</category>
        
      </item>
    
      <item>
        <title>Java Adv 20 - 자바 동시성 컬렉션 - 2</title>
        <description>&lt;h2 id=&quot;동시성-컬렉션concurrent-collections&quot;&gt;&lt;strong&gt;동시성 컬렉션(Concurrent Collections)&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;자바 1.5부터 멀티스레드 환경에서 성능을 최적화하면서 동시성을 지원하는 여러 가지 컬렉션들이 추가되었다. 
이 컬렉션들은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java.util.concurrent&lt;/code&gt; 패키지에 포함되어 있으며, 
스레드 안전(Thread Safe)하고 성능을 고려한 다양한 동기화 기법을 적용하여, 멀티스레드 환경에서의 효율적인 데이터 처리와 동시 접근을 지원한다.&lt;/p&gt;

&lt;h2 id=&quot;동시성-컬렉션의-특징&quot;&gt;동시성 컬렉션의 특징&lt;/h2&gt;

&lt;p&gt;기존의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java.util&lt;/code&gt; 패키지에서 제공하는 컬렉션들은 기본적으로 스레드 안전하지 않다. 
이러한 컬렉션들(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ArrayList&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HashMap&lt;/code&gt; 등)은 여러 스레드가 동시에 접근할 경우 데이터 불일치나 경쟁 상태(race condition)를 일으킬 수 있다. 
반면, 동시성 컬렉션들은 멀티스레드 환경에서 동기화 문제를 해결하면서도 성능 최적화를 고려하여 설계되었다.
동시성 컬렉션은 &lt;strong&gt;정교한 잠금 메커니즘&lt;/strong&gt;을 사용한다. 
예를 들어, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lock&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CAS(Compare-And-Swap)&lt;/code&gt;, &lt;strong&gt;분할 잠금(segment lock)&lt;/strong&gt; 등을 활용하여 
각 스레드가 경쟁적으로 데이터를 수정하지 않도록 하고, 여러 스레드가 동시에 안전하게 접근할 수 있도록 지원한다.&lt;/p&gt;

&lt;h2 id=&quot;동시성-컬렉션-클래스&quot;&gt;동시성 컬렉션 클래스&lt;/h2&gt;

&lt;p&gt;자바는 여러 종류의 동시성 컬렉션을 제공하며, 이를 통해 다양한 자료 구조의 동기화 문제를 해결할 수 있다. 아래는 자주 사용되는 동시성 컬렉션 클래스들이다&lt;/p&gt;

&lt;h3 id=&quot;1-list&quot;&gt;1. &lt;strong&gt;List&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;**&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CopyOnWriteArrayList**ArrayList&lt;/code&gt;의 대안으로, 내부 배열을 복사하여 수정하는 방식으로 동기화를 처리한다.&lt;/li&gt;
  &lt;li&gt;읽기 작업이 많고 쓰기 작업이 적은 경우에 적합하다.&lt;/li&gt;
  &lt;li&gt;멀티스레드 환경에서 쓰기 작업이 발생할 때마다 배열이 복사되므로 쓰기 작업의 성능이 떨어질 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-set&quot;&gt;2. &lt;strong&gt;Set&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;CopyOnWriteArraySet&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HashSet&lt;/code&gt;의 대안으로, 내부적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CopyOnWriteArrayList&lt;/code&gt;를 사용하여 동기화를 처리한다.&lt;/li&gt;
      &lt;li&gt;쓰기 작업이 많은 환경에서는 성능 저하가 있을 수 있지만, 읽기 작업이 많은 환경에서 유리하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ConcurrentSkipListSet&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TreeSet&lt;/code&gt;의 대안으로, 정렬된 순서를 유지하면서 스레드 안전성을 보장한다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Comparator&lt;/code&gt;를 사용하여 정렬 순서를 설정할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3-map&quot;&gt;3. &lt;strong&gt;Map&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;ConcurrentHashMap&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;의 대안으로, 내부적으로 &lt;strong&gt;분할 잠금&lt;/strong&gt;(Segment Lock)을 사용하여 성능을 최적화한다. 여러 스레드가 동시에 다른 세그먼트에 접근할 수 있어 동시성 처리 성능이 뛰어나다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ConcurrentSkipListMap&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TreeMap&lt;/code&gt;의 대안으로, 정렬된 순서를 유지하면서 스레드 안전성을 보장한다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Comparator&lt;/code&gt;를 사용하여 정렬 순서를 설정할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-queue&quot;&gt;4. &lt;strong&gt;Queue&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;ConcurrentLinkedQueue&lt;/strong&gt;비차단(non-blocking) 큐로, &lt;strong&gt;CAS&lt;/strong&gt;(Compare-And-Swap) 기법을 사용하여 스레드 안전성을 보장한다. 여러 스레드가 동시에 큐에 접근할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;5-deque&quot;&gt;5. &lt;strong&gt;Deque&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;ConcurrentLinkedDeque&lt;/strong&gt;비차단(non-blocking) 덱(Deque)으로, 양쪽 끝에서 삽입 및 삭제가 가능하며, CAS 기법을 사용해 동기화가 이루어진다. 멀티스레드 환경에서 효율적으로 사용된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;blockingqueue&quot;&gt;BlockingQueue&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BlockingQueue&lt;/code&gt;는 데이터를 삽입하거나 제거할 때 &lt;strong&gt;차단(blocking)&lt;/strong&gt; 기능을 제공하는 큐로, 주로 생산자-소비자 패턴에서 사용된다. 여러 종류의 블로킹 큐가 제공되며, 각 큐는 고유의 특징을 가지고 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;ArrayBlockingQueue&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;고정 크기의 블로킹 큐로, 큐가 가득 찼을 때 삽입을 차단하고, 큐가 비었을 때 제거를 차단한다. 공정(fair) 모드를 지원하며, 이를 통해 큐에 접근하는 스레드의 순서를 보장할 수 있다. 그러나 공정 모드를 사용하면 성능 저하가 발생할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;LinkedBlockingQueue&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;크기가 고정되거나 무한인 블로킹 큐로, 큐가 가득 차면 삽입을 차단하고, 큐가 비면 제거를 차단한다. 큐의 크기가 동적으로 조정될 수 있어 유연하게 사용될 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;PriorityBlockingQueue&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;우선순위가 높은 요소를 먼저 처리하는 블로킹 큐이다. 우선순위는 자연 순서나 사용자가 제공하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Comparator&lt;/code&gt;에 의해 결정된다. 데이터가 삽입된 순서와는 상관없이 우선순위가 높은 요소가 먼저 처리된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;SynchronousQueue&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;데이터 저장소가 없는 블로킹 큐로, 생산자가 데이터를 삽입하면 소비자가 데이터를 받을 때까지 대기한다. 이 큐는 직접적인 &lt;strong&gt;핸드오프(hand-off)&lt;/strong&gt; 메커니즘을 제공하여 생산자와 소비자가 데이터를 직접 주고받을 수 있게 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;DelayQueue&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;요소가 지정된 시간만큼 지연된 후에야 소비될 수 있는 블로킹 큐이다. 시간 지연이 필요한 작업을 처리하는 데 유용하다. 주로 스케줄링 작업이나 지연된 작업을 처리할 때 사용된다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;동시성-컬렉션의-장점과-단점&quot;&gt;동시성 컬렉션의 장점과 단점&lt;/h3&gt;

&lt;h3 id=&quot;장점&quot;&gt;장점&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;성능 최적화&lt;/strong&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ConcurrentHashMap&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CopyOnWriteArrayList&lt;/code&gt;와 같은 컬렉션은 동기화 기법을 정교하게 적용하여 멀티스레드 환경에서 성능을 최적화한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;유연한 동기화&lt;/strong&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java.util.concurrent&lt;/code&gt; 패키지의 컬렉션들은 특정 메서드에만 동기화를 적용하거나, 잠금 범위를 세밀하게 조정하는 등의 유연한 동기화 전략을 제공한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;스레드 안전&lt;/strong&gt;: 멀티스레드 환경에서 데이터를 안전하게 처리할 수 있어, 동시 접근 시 발생할 수 있는 데이터 불일치나 경쟁 상태를 방지할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;단점&quot;&gt;단점&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;복잡한 구현&lt;/strong&gt;: 동시성 컬렉션의 내부 구현은 복잡하고 고급 동기화 기법을 사용하므로, 이를 잘못 사용하면 성능이 저하될 수 있다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;메모리 소비&lt;/strong&gt;: 일부 동시성 컬렉션은 추가적인 메모리 오버헤드를 발생시킬 수 있다. 예를 들어, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CopyOnWriteArrayList&lt;/code&gt;는 매번 데이터를 복사하므로 메모리 사용량이 증가할 수 있다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;성능 저하&lt;/strong&gt;: 동시성 컬렉션은 비록 멀티스레드 환경에서 안전하지만, 적절한 상황에서 사용되지 않으면 불필요한 동기화로 인해 성능 저하가 발생할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;프록시 패턴을 이용하여 모든 객체에&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;p&gt;김영한님의 자바 강의&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/essential/concurrency/sync.html&quot;&gt;https://docs.oracle.com/javase/tutorial/essential/concurrency/sync.html&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Thu, 24 Oct 2024 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/language/2024/10/24/Java-Adv-20/</link>
        <guid isPermaLink="true">http://localhost:4000/language/2024/10/24/Java-Adv-20/</guid>
        
        <category>java</category>
        
        
        <category>language</category>
        
      </item>
    
      <item>
        <title>Java Adv 19 - 자바 동시성 컬렉션</title>
        <description>&lt;h2 id=&quot;자바-synchronized-프록시&quot;&gt;&lt;strong&gt;자바&lt;/strong&gt; synchronized &lt;strong&gt;프록시&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;자바에서 제공하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java.util&lt;/code&gt; 패키지의 컬렉션 프레임워크는 대부분 스레드 안전(Thread Safe)하지 않다. 
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ArrayList&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LinkedList&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HashSet&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HashMap&lt;/code&gt; 등의 기본 자료 구조들은 여러 연산들이 동시에 이루어지기 때문에 동기화가 필요하다. 
그러나 모든 자료 구조에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;synchronized&lt;/code&gt;를 사용하여 동기화를 해두는 것은 성능 저하를 초래할 수 있다. 
동기화는 스레드 안전을 보장하지만, 멀티스레드 환경에서만 필요한 기능이다. 
동기화를 미리 적용하면 단일 스레드 환경에서도 불필요한 성능 저하가 발생할 수 있다. 
따라서 동기화의 필요성을 정확히 판단하고, 꼭 필요한 경우에만 동기화를 적용하는 것이 중요하다.
&lt;strong&gt;Vector&lt;/strong&gt;는 과거에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ArrayList&lt;/code&gt;와 비슷한 기능을 제공하며, 모든 메서드에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;synchronized&lt;/code&gt;를 적용하여 동기화를 보장했다. 
그러나 이로 인해 단일 스레드 환경에서 성능이 저하되었고, 결국 널리 사용되지 않게 되었다. 지금은 하위 호환성을 위해 남아있지만, 다른 대안들이 존재하기 때문에 사용을 권장하지 않는다.
대신, 동기화를 필요에 따라 적용할 수 있는 방법으로 &lt;strong&gt;프록시 패턴&lt;/strong&gt;을 사용할 수 있다. 
예를 들어, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Collections.synchronizedList()&lt;/code&gt; 메서드를 사용하면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ArrayList&lt;/code&gt;를 동기화된 리스트로 변환할 수 있다. 
이 메서드는 내부적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SynchronizedRandomAccessList&lt;/code&gt;라는 클래스를 사용하여 동기화를 적용한다. 이렇게 하면 기존 코드의 구조를 유지하면서, 필요한 경우에만 동기화를 적용할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Collections&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;synchronizedList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;());&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img width=&quot;648&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/53881711-199e-4484-9218-40628e5560ce&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 코드에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;synchronizedList()&lt;/code&gt; 메서드는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ArrayList&lt;/code&gt;를 감싸는 동기화된 리스트를 반환한다. 
이 리스트의 메서드는 내부적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;synchronized&lt;/code&gt; 키워드를 사용하여 동기화를 보장한다. 예를 들어, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add()&lt;/code&gt; 메서드는 다음과 같이 동기화된 코드로 구현된다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Collections&lt;/code&gt;는 이와 같이 여러 종류의 동기화 프록시 메서드를 제공하여, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;List&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Set&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Map&lt;/code&gt; 등의 컬렉션을 동기화된 버전으로 변환할 수 있게 해준다. 
예를 들어, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;synchronizedMap()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;synchronizedSet()&lt;/code&gt; 등의 메서드를 통해 동기화된 컬렉션을 생성할 수 있다.
하지만 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;synchronized&lt;/code&gt; 프록시를 사용하는 방식에는 단점이 있다. 첫째, 동기화 오버헤드가 발생한다. 
모든 메서드 호출 시마다 동기화가 이루어지기 때문에 성능이 저하될 수 있다. 
둘째, 전체 컬렉션에 대해 동기화가 이루어지기 때문에 잠금 범위가 넓어지고, 이는 잠금 경합(lock contention)을 증가시켜 병렬 처리의 효율성을 저하시킬 수 있다. 
셋째, 선택적인 동기화가 어려워, 과도한 동기화로 이어질 수 있다.
따라서 자바는 이러한 단점을 보완하기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java.util.concurrent&lt;/code&gt; 패키지에서 더 정교한 동시성 컬렉션(concurrent collection)을 제공한다. 
이 컬렉션들은 동기화 오버헤드를 최소화하고, 동기화의 효율성을 높이며, 멀티스레드 환경에서 성능을 극대화할 수 있도록 설계되었다.&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;p&gt;김영한님의 자바 강의&lt;/p&gt;

</description>
        <pubDate>Wed, 23 Oct 2024 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/language/2024/10/23/Java-Adv-19/</link>
        <guid isPermaLink="true">http://localhost:4000/language/2024/10/23/Java-Adv-19/</guid>
        
        <category>java</category>
        
        
        <category>language</category>
        
      </item>
    
      <item>
        <title>Java Adv 18 - 동시성 컬렉션이 필요한 이유 - 3</title>
        <description>&lt;h2 id=&quot;프록시proxy&quot;&gt;&lt;strong&gt;프록시&lt;/strong&gt;(Proxy)&lt;/h2&gt;

&lt;p&gt;우리말로 대리자, 대신 처리해주는 자라는 뜻이다.
프록시를 쉽게 풀어서 설명하자면 친구에게 대신 음식을 주문해달라고 부탁하는 상황을 생각해 볼 수 있다. 
예를 들어,당신이 피자를 먹고 싶은데, 직접 전화하는 게 부담스러워서 친구에게 대신 전화해서 피자를 주문해달라고 부탁한다고 해보자. 
친구가 피자 가게에 전화를 걸어 주문하고, 피자가 도착하면 당신에게 가져다주는 것이다. 여기서 친구가 프록시 역할을 하는 것이다.
나(클라이언트) 피자 가게(서버), 나(클라이언트) 친구(프록시) 피자 가게(서버)
객체 세상에도 이런 프록시를 만들 수 있다. 여기서는 프록시가 대신 동기화(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;synchronized&lt;/code&gt; ) 기능을 처리해주는 것이다. 코드를 만들면서 확인해보자.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;654&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/7a2c45de-36af-43de-8748-8a095f0d22c7&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SyncProxyList&lt;/code&gt; 는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BasicList&lt;/code&gt; 와 같은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SimpleList&lt;/code&gt; 인터페이스를 구현한다.
이 클래스는 생성자를 통해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SimpleList target&lt;/code&gt; 을 주입 받는다. 여기에 실제 호출되는 대상이 들어간다.
이 클래스는 마치 빈껍데기 처럼 보인다. 이 클래스의 역할은 모든 메서드에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;synchronized&lt;/code&gt; 를 걸어주는 일 뿐
이다. 그리고나서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;target&lt;/code&gt; 에 있는 같은 기능을 호출한다.
이 프록시 클래스는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;synchronized&lt;/code&gt; 만 걸고, 그 다음에 바로 실제 호출해야 하는 원본 대상(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;target&lt;/code&gt; )을 호출한다.
기존에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BasicList&lt;/code&gt; 를 직접 사용하고 있었다면, 이제 중간에 프록시를 사용하므로 다음과 같은 구조로 변경된다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;기존 구조&lt;/em&gt;&lt;/strong&gt;: 클라이언트 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BasicList&lt;/code&gt; (서버)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;변경 구조&lt;/em&gt;&lt;/strong&gt;: 클라이언트 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SyncProxyList&lt;/code&gt; (프록시) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BasicList&lt;/code&gt; (서버)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img width=&quot;654&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/43761ecd-1d87-4cf0-a71f-b6ed1b6f031c&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림과 같이 정적인 클래스의 의존 관계를 정적 의존 관계라 한다.
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;test()&lt;/code&gt; 메서드를 클라이언트라고 가정하자. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;test()&lt;/code&gt; 메서드는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SimpleList&lt;/code&gt; 라는 인터페이스에만 의존한
다. 이것을 추상화에 의존한다고 표현한다. 덕분에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SimpleList&lt;/code&gt; 인터페이스의 구현체인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BasicList&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SyncList&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SyncProxyList&lt;/code&gt; 중에 어떤 것을 사용하든, 클라이언트인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;test()&lt;/code&gt; 의 코드는 전혀 변경하지 않아도 된다. 클라이언트인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;test()&lt;/code&gt; 입장에서 생각해보면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BasicList&lt;/code&gt; 가 넘어올지, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SyncProxyList&lt;/code&gt; 가 넘어올지 알 수없다. 단순히 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SimpleList&lt;/code&gt; 의 구현체 중의 하나가 넘어와서 실행된다는 정도만 알 수 있다. 그래서 클라이언트인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;test()&lt;/code&gt; 는 매우 유연하다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BasicList&lt;/code&gt; 의 어떤 구현체든지 다 받아들일 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;런타임-의존관계&quot;&gt;런타임 의존관계&lt;/h2&gt;

&lt;p&gt;먼저 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BasicList&lt;/code&gt; 를 사용하는 예를 보자.&lt;/p&gt;

&lt;p&gt;실제 런타임에 발생하는 인스턴스의 의존 관계를 런타임 의존 관계라 한다.
먼저 간단한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BasicList&lt;/code&gt; 를 직접 사용하는 경우부터 알아보자. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;test(new BasicList())&lt;/code&gt; 를 실행하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BasicList(x001)&lt;/code&gt; 의 인스턴스가 만들어지면서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;test()&lt;/code&gt; 메서드에 전달된다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;test()&lt;/code&gt; 메서드는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BasicList(x001)&lt;/code&gt; 인스턴스의 참조를 알고 사용하게된다.&lt;/p&gt;

&lt;p&gt;다음 두 코드는 같은 코드이므로 쉽게 풀어서 설명하겠다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SyncProxyList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BasicList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;SimpleList&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;basicList&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BasicList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;SimpleList&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SyncProxyList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;basicList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;SimpleList basicList = new BasicList();&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BasicList&lt;/code&gt;의 인스턴스가 생성되며, 이 인스턴스는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x001&lt;/code&gt;이라는 고유 참조를 가진다.&lt;/li&gt;
      &lt;li&gt;이 인스턴스를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;basicList&lt;/code&gt;라는 이름의 변수에 저장한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;SimpleList list = new SyncProxyList(basicList);&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SyncProxyList&lt;/code&gt;의 인스턴스가 생성된다.&lt;/li&gt;
      &lt;li&gt;생성 시에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;basicList&lt;/code&gt;의 참조인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BasicList(x001)&lt;/code&gt;을 인수로 전달받는다.&lt;/li&gt;
      &lt;li&gt;이렇게 만들어진 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SyncProxyList(x002)&lt;/code&gt;는 내부에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;target&lt;/code&gt;이라는 변수로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BasicList(x001)&lt;/code&gt;의 참조를 저장하고 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;test(list);&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;test&lt;/code&gt; 메서드에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SyncProxyList(x002)&lt;/code&gt;가 전달된다.&lt;/li&gt;
      &lt;li&gt;이때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SyncProxyList&lt;/code&gt;를 통해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BasicList&lt;/code&gt;의 기능에 접근하게 된다.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SyncProxyList&lt;/code&gt;는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BasicList&lt;/code&gt;의 기능을 호출하기 전에 동기화 처리나 추가 기능을 적용한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;p&gt;김영한님의 자바 강의&lt;/p&gt;

</description>
        <pubDate>Tue, 22 Oct 2024 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/language/2024/10/22/Java-Adv-18/</link>
        <guid isPermaLink="true">http://localhost:4000/language/2024/10/22/Java-Adv-18/</guid>
        
        <category>java</category>
        
        
        <category>language</category>
        
      </item>
    
      <item>
        <title>Java Adv 17 - 동시성 컬렉션이 필요한 이유 - 2</title>
        <description>&lt;h2 id=&quot;멀티스레드-환경에서의-문제-확인&quot;&gt;&lt;strong&gt;멀티스레드 환경에서의&lt;/strong&gt; &lt;strong&gt;문제&lt;/strong&gt; &lt;strong&gt;확인&lt;/strong&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;add() - &lt;strong&gt;원자적이지&lt;/strong&gt; &lt;strong&gt;않은&lt;/strong&gt; &lt;strong&gt;연산&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;elementData&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 멀티스레드 문제를 쉽게 확인하는 코드&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;실제-멀티스레드-환경에서-사용&quot;&gt;실제 멀티스레드 환경에서 사용&lt;/h2&gt;

&lt;p&gt;&lt;img width=&quot;654&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/1df3107a-8019-425b-a3c4-eb93a27f4ffe&quot; /&gt;
&lt;img width=&quot;654&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/53700c67-e92a-48d9-a3b3-5f64702eeeee&quot; /&gt;&lt;/p&gt;

&lt;p&gt;테스트 코드를 간단하게 작성해서 각각의 Thread가 A와 B를 list에 저장하게끔 하였다.
원자적 연산을 지원하지는 않겠지만 어떤 결과를 확인해 볼 수 있을까?&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;654&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/23e569ab-ce80-4eaf-a6f4-065b6bb63d8e&quot; /&gt;&lt;/p&gt;

&lt;p&gt;스레드1 수행: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;elementData[0] = A&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;elementData[0]&lt;/code&gt; 의 값은 A가 된다.
스레드2 수행: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;elementData[0] = B&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;elementData[0]&lt;/code&gt; 의 값은 A → B가 된다.&lt;/p&gt;

&lt;p&gt;이 말이 무슨말이냐면 스레드1이 elementData[0]에 A를 저장하고, 동시에 B도 0에다가 저장을 하기 때문에
인덱스 0번에 A가 저장되었다가 B로 바뀌는 것을 말한다.
그리고 size++을 보면 size++은 size = size + 1이다  Thread-1이 size++; 연산을 실행하면 1이 저장이 되어있고, 
그 뒤에 thread-2가 1을 더하면 2가 저장이 되는데 이 밖의 상황도 발생할 수가 있다.
thread-1이 1을 증가시킬 때 동시에 thread-2도 같은 연산을 실행해서 size의 저장되어 있는 값이 0이었기 때문에 
1로 증가시키는 연산을 진행하면 2가 아닌 1이 출력될 수 있다. 이렇게 되버리면 데이터의 정합성이 모두 깨진다.&lt;/p&gt;

&lt;h2 id=&quot;컬렉션-프레임워크-대부분은-스레드-세이프-하지-않다&quot;&gt;&lt;strong&gt;컬렉션 프레임워크 대부분은 스레드 세이프 하지 않다&lt;/strong&gt;.&lt;/h2&gt;

&lt;p&gt;일반적으로 자주 사용하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ArrayList&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LinkedList&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HashSet&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HashMap&lt;/code&gt; 등 수 많은 자료 구조들은 단순한 연산을 제공하는 것 처럼 보인다. 
예를 들어서 데이터를 추가하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add()&lt;/code&gt; 와 같은 연산은 마치 원자적인 연산처럼 느껴진다. 
하지만 그 내부에서는 수 많은 연산들이 함께 사용된다. 
배열에 데이터를 추가하고, 사이즈를 변경하고, 배열을 새로 만들어서 배열의 크기도 늘리고, 
노드를 만들어서 링크에 연결하는 등 수 많은 복잡한 연산이 함께 사용된다.
따라서 일반적인 컬렉션들은 절대로! 스레드 세이프 하지 않다!
단일 스레드가 컬렉션에 접근하는 경우라면 아무런 문제가 없지만, 
멀티스레드 상황에서 여러 스레드가 동시에 컬렉션에 접근하는 경우라면 
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java.util&lt;/code&gt; 패키지가 제공하는 일반적인 컬렉션들은 사용하면 안된다! 
최악의 경우 실무에서 두 명의 사용자가 동시에 컬렉션에 데이터를 보관했는데, 
코드에 아무런 문제가 없어 보이는데, 한명의 사용자 데이터가 사라질 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;아주-간단한-동시성-해결&quot;&gt;아주 간단한 동시성 해결&lt;/h2&gt;

&lt;p&gt;&lt;img width=&quot;654&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/8f76ceae-189b-4f28-b138-dc4024623493&quot; /&gt;&lt;/p&gt;

&lt;p&gt;사실 synchronized라는 키워드 하나를 걸어주면 동시성이 해결된다.
멀티스레드 환경에서 안전하게 사용이 가능하다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;654&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/185af355-91ff-4969-9f7e-d6cc3e0a3d74&quot; /&gt;&lt;/p&gt;

&lt;p&gt;구현체를 SyncList로 갈아껴주었다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;654&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/ca93b988-cd27-4e3c-9e84-de8bc4950cdf&quot; /&gt;&lt;/p&gt;

&lt;p&gt;안전한 임계영역을 형성해주면 컬렉션 프레임워크도 멀티스레드 환경에서 안전하게 사용할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;p&gt;김영한님의 자바 강의&lt;/p&gt;

</description>
        <pubDate>Mon, 21 Oct 2024 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/language/2024/10/21/Java-Adv-17/</link>
        <guid isPermaLink="true">http://localhost:4000/language/2024/10/21/Java-Adv-17/</guid>
        
        <category>java</category>
        
        
        <category>language</category>
        
      </item>
    
      <item>
        <title>Java Adv 16 - 동시성 컬렉션이 필요한 이유</title>
        <description>&lt;h2 id=&quot;컬렉션-프레임워크는-원자적인-연산을-제공할까&quot;&gt;컬렉션 프레임워크는 원자적인 연산을 제공할까?&lt;/h2&gt;

&lt;p&gt;예를 들어서 ArrayList가 인스턴스에 여러 스레드가 동시에 접근을 한다면?
참고로 스레드가 동시에 접근을 해도 괜찮은 경우를 &lt;strong&gt;스레드 세이프&lt;/strong&gt; 하다고 한다.
그렇다면 ArrayList는 스레드 세이프 할까?
예제 코드로 확인 해보자&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;654&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/0c203765-49f3-437e-9e68-a4e4f2881542&quot; /&gt;&lt;/p&gt;

&lt;p&gt;여기서는 멀티스레드를 사용하지 않지만, &lt;strong&gt;**스레드&lt;/strong&gt;1&lt;strong&gt;과&lt;/strong&gt; &lt;strong&gt;스레드&lt;/strong&gt;2&lt;strong&gt;가&lt;/strong&gt; &lt;strong&gt;동시에&lt;/strong&gt; &lt;strong&gt;다음&lt;/strong&gt; &lt;strong&gt;코드를&lt;/strong&gt; &lt;strong&gt;실행한다고&lt;/strong&gt; &lt;strong&gt;가정&lt;/strong&gt;**해보자.
스레드1: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;list&lt;/code&gt; 에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt; 를 추가한다.
스레드2: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;list&lt;/code&gt; 에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B&lt;/code&gt; 를 추가한다.
컬렉션에 데이터를 추가하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add()&lt;/code&gt; 메서드를 생각해보면, 단순히 컬렉션에 데이터를 하나 추가하는 것뿐이다. 
따라서 이것은 마치 연산이 하나만 있는 원자적인 연산처럼 느껴진다. 
원자적인 연산은 쪼갤 수 없기 때문에 멀티스레드 상황에 문제가 되지 않는다. 
물론 멀티스레드는 중간에 스레드의 실행 순서가 변경될 수 있으므로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[A, B]&lt;/code&gt; 또는, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[B, A]&lt;/code&gt;는 변경될 수 있지만, 
결과적으로 데이터는 모두 안전하게 저장될 것 같다. 
하지만 컬렉션 프레임워크가 제공하는 대부분의 연산은 원자적인 연산이 아니다.&lt;/p&gt;

&lt;h2 id=&quot;구현&quot;&gt;구현&lt;/h2&gt;

&lt;p&gt;&lt;img width=&quot;654&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/0ff61560-e3af-4a26-a7b4-de0d3dfa979a&quot; /&gt;
&lt;img width=&quot;654&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/27e502f2-c138-4110-9c66-6a8dcbdf1569&quot; /&gt;
&lt;img width=&quot;654&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/1fd82128-9e9c-4144-b205-ac0c9783c267&quot; /&gt;
&lt;img width=&quot;654&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/aafd213e-011d-4d26-9399-f72674efe14d&quot; /&gt;&lt;/p&gt;

&lt;p&gt;가장 간단한 컬렉션의 구현이다. 내부에서는 배열을 사용해서 데이터를 보관한다.
ArrayList:최소 구현 버전이라 생각하면 된다.
DEFAULT_CAPACITY: 최대 5의 데이터를 저장할 수 있다. (필드 값으로 구현을 해두었다.)
size: 저장한 데이터의 크기를 나타낸다.
add(): 컬렉션에 데이터를 추가한다.
sleep(100): 잠시 기대한다. 이렇게 하면 멀티스레드 상황에 발생하는 문제를 확인하기 쉽다.
단일 스레드로 실행했기 때문에 아직까지는 아무런 문제 없이 잘 작동한다. 과연 멀티스레드 환경에서는 어떨까?&lt;/p&gt;

&lt;h2 id=&quot;코드에-sleep을-준-이유는&quot;&gt;코드에 sleep을 준 이유는?&lt;/h2&gt;

&lt;p&gt;스레드 간 자원 경쟁: 여러 스레드가 동일한 자원(예: 변수, 객체, 데이터베이스 등)을 접근하려고 할 때, 
sleep()을 사용하면 자원에 접근하는 타이밍을 다르게 하여 경쟁 상황을 의도적으로 유발할 수 있다. 
이로 인해 동기화 문제가 발생하는지 확인할 수 있다. (의도적으로 타이밍을 다르게 준 것)&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;p&gt;김영한님의 자바 강의&lt;/p&gt;

</description>
        <pubDate>Sun, 20 Oct 2024 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/language/2024/10/20/Java-Adv-16/</link>
        <guid isPermaLink="true">http://localhost:4000/language/2024/10/20/Java-Adv-16/</guid>
        
        <category>java</category>
        
        
        <category>language</category>
        
      </item>
    
      <item>
        <title>백준 2636 문제풀이</title>
        <description>&lt;h2 id=&quot;문제-링크&quot;&gt;문제 링크&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/2636&quot;&gt;https://www.acmicpc.net/problem/2636&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h2&gt;

&lt;p&gt;아래 &amp;lt;그림 1&amp;gt;과 같이 정사각형 칸들로 이루어진 사각형 모양의 판이 있고, 
그 위에 얇은 치즈(회색으로 표시된 부분)가 놓여 있다. 
판의 가장자리(&amp;lt;그림 1&amp;gt;에서 네모 칸에 X친 부분)에는 치즈가 놓여 있지 않으며 치즈에는 하나 이상의 구멍이 있을 수 있다.
이 치즈를 공기 중에 놓으면 녹게 되는데 공기와 접촉된 칸은 한 시간이 지나면 녹아 없어진다. 
치즈의 구멍 속에는 공기가 없지만 구멍을 둘러싼 치즈가 녹아서 구멍이 열리면 구멍 속으로 공기가 들어가게 된다.
&amp;lt;그림 1&amp;gt;의 경우, 치즈의 구멍을 둘러싼 치즈는 녹지 않고 ‘c’로 표시된 부분만 한 시간 후에 녹아 없어져서 &amp;lt;그림 2&amp;gt;와 같이 된다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;301&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/ac4c4140-7f72-4d34-9631-9220d4bd3c67&quot; /&gt;
&lt;img width=&quot;397&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/d97b0738-8548-4be0-8a3c-53a1cc6f0380&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;그림 3&amp;gt;은 원래 치즈의 두 시간 후 모양을 나타내고 있으며, 남은 조각들은 한 시간이 더 지나면 모두 녹아 없어진다. 
그러므로 처음 치즈가 모두 녹아 없어지는 데는 세 시간이 걸린다.
&amp;lt;그림 3&amp;gt;과 같이 치즈가 녹는 과정에서 여러 조각으로 나누어 질 수도 있다.
입력으로 사각형 모양의 판의 크기와 한 조각의 치즈가 판 위에 주어졌을 때, 
공기 중에서 치즈가 모두 녹아 없어지는 데 걸리는 시간과 모두 녹기 한 시간 전에 남아있는 치즈조각이 놓여 있는 칸의 개수를 구하는 프로그램을 작성하시오.&lt;/p&gt;

&lt;h2 id=&quot;문제-분석&quot;&gt;문제 분석&lt;/h2&gt;

&lt;p&gt;이 문제는 치즈가 녹는 과정을 시뮬레이션하는 문제이다. 
주어진 격자에서 치즈는 외부 공기와 접촉한 부분부터 녹기 시작한다. 
이를 해결하기 위해, 외부 공기와 접촉한 치즈를 찾아내고 그 치즈를 녹여서 없애는 작업을 반복하는 방식으로 접근한다. 
먼저, 주어진 격자에서 치즈와 공기를 구분하여 표시하는데, 치즈는 1, 공기는 0으로 표시된다. 
방문 여부를 체크하기 위해 visited 배열을 사용한다. 
go 함수는 주어진 위치에서 외부 공기와 접촉한 치즈를 찾아내는 함수이다. 
이 함수에서 치즈가 발견되면 그 위치를 벡터 v에 저장하고, 그 후에는 인접한 네 방향으로 탐색을 이어가는데 이미 방문한 칸은 다시 방문하지 않도록 visited 배열을 사용한다. 
go 함수는 재귀적으로 호출되어 치즈와 공기의 경계를 탐색하며 외부 공기와 접촉한 치즈를 찾는다. 치즈가 외부 공기와 접촉했다면 그 위치를 v에 기록하고, go 함수는 종료된다. 
치즈를 녹이는 과정은 go(0, 0)을 호출한 후, 벡터 v에 저장된 치즈들의 좌표를 a[b.first][b.second] = 0으로 변경하여 해당 위치의 치즈를 없애는 방식으로 진행된다.&lt;/p&gt;

&lt;h2 id=&quot;코드&quot;&gt;코드&lt;/h2&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;lt;bits/stdc++.h&amp;gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;104&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;104&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;visited&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;104&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;104&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;   
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cnt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cnt2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pair&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;go&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;visited&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ny&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ny&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ny&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;visited&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ny&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
        &lt;span class=&quot;n&quot;&gt;go&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ny&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;


&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;cin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;cin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt; 
        &lt;span class=&quot;n&quot;&gt;fill&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;visited&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;visited&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;104&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;104&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;clear&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; 
        &lt;span class=&quot;n&quot;&gt;go&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; 
        &lt;span class=&quot;n&quot;&gt;cnt2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pair&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt; 
            &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;   
        &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;cnt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cnt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'\n'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cnt2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'\n'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;v벡터에 외부 공기와 접촉된 치즈들의 좌표가 저장이되고, a[b.first][b.second] = 0;을 통해서 치즈를 1 -&amp;gt; 0으로 
바꿔주는 것에서 치즈를 지울 수 있었다.
상태변화는 항상 0 -&amp;gt; 1, 1 -&amp;gt; 0으로 만들어주는 아이디어가 핵심이다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;1143&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/fb2558ea-e2f8-49f4-bc98-1eb48c7ad7ec&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;p&gt;나의 뇌&lt;/p&gt;
</description>
        <pubDate>Sat, 19 Oct 2024 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/cs/2024/10/19/Algorithm-21/</link>
        <guid isPermaLink="true">http://localhost:4000/cs/2024/10/19/Algorithm-21/</guid>
        
        <category>Algorithm</category>
        
        
        <category>cs</category>
        
      </item>
    
      <item>
        <title>백준 4949 문제풀이</title>
        <description>&lt;h2 id=&quot;문제-링크&quot;&gt;문제 링크&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/4949&quot;&gt;https://www.acmicpc.net/problem/4949&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h2&gt;

&lt;p&gt;세계는 균형이 잘 잡혀있어야 한다. 양과 음, 빛과 어둠 그리고 왼쪽 괄호와 오른쪽 괄호처럼 말이다.
정민이의 임무는 어떤 문자열이 주어졌을 때, 괄호들의 균형이 잘 맞춰져 있는지 판단하는 프로그램을 짜는 것이다.
문자열에 포함되는 괄호는 소괄호(“()”) 와 대괄호(“[]”)로 2종류이고, 문자열이 균형을 이루는 조건은 아래와 같다.
모든 왼쪽 소괄호(“(“)는 오른쪽 소괄호(“)”)와만 짝을 이뤄야 한다.
모든 왼쪽 대괄호(“[“)는 오른쪽 대괄호(“]”)와만 짝을 이뤄야 한다.
모든 오른쪽 괄호들은 자신과 짝을 이룰 수 있는 왼쪽 괄호가 존재한다.
모든 괄호들의 짝은 1:1 매칭만 가능하다. 즉, 괄호 하나가 둘 이상의 괄호와 짝지어지지 않는다.
짝을 이루는 두 괄호가 있을 때, 그 사이에 있는 문자열도 균형이 잡혀야 한다.
정민이를 도와 문자열이 주어졌을 때 균형잡힌 문자열인지 아닌지를 판단해보자.&lt;/p&gt;

&lt;h2 id=&quot;문제-분석&quot;&gt;문제 분석&lt;/h2&gt;

&lt;p&gt;이 문제는 stack을 이용하여 문제를 풀이하였다.
일반적인 짝짓기 문제이고, 소괄호 뿐만이 아닌 대괄호에 대한 규칙만 추가를 해주면 된다.
띄어쓰기와 온점을 이용한 종료조건까지 추가를 해주는 것 때문에 getline()을 사용해서 문제를 풀었다.
(getline을 잘 사용하지 않다보니 처음에는 애를 먹었다..)
두가지 방법으로 문제를 풀어보았다. 사실 두가지 방법이지만 문제의 해결방식은 똑같다.&lt;/p&gt;

&lt;h2 id=&quot;코드&quot;&gt;코드&lt;/h2&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt;&lt;span class=&quot;cpf&quot;&gt;&amp;lt;bits/stdc++.h&amp;gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ios_base&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sync_with_stdio&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tie&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tie&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;getline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;.&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;check&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;')'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;top&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'['&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;check&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;stk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;']'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;top&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'('&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;check&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;stk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'('&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'['&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;check&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;yes&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'\n'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;no&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'\n'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;lt;bits/stdc++.h&amp;gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;check&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'('&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'['&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;stk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; 
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; 
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;')'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;']'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;')'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;top&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'('&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;']'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;top&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'['&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;stk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; 
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; 
            &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;getline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; 
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;.&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;check&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;yes&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'\n'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;no&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'\n'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;띄어쓰기까지 고려한 문자열을 받게 된다면 getline을 사용하자&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;1133&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/e5fd3d58-5670-402e-8f96-a38a1890fb7e&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;p&gt;나의 뇌&lt;/p&gt;
</description>
        <pubDate>Fri, 18 Oct 2024 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/cs/2024/10/18/Algorithm-20/</link>
        <guid isPermaLink="true">http://localhost:4000/cs/2024/10/18/Algorithm-20/</guid>
        
        <category>Algorithm</category>
        
        
        <category>cs</category>
        
      </item>
    
      <item>
        <title>백준 9012 문제풀이</title>
        <description>&lt;h2 id=&quot;문제-링크&quot;&gt;문제 링크&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/9012&quot;&gt;https://www.acmicpc.net/problem/9012&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h2&gt;

&lt;p&gt;괄호 문자열(Parenthesis String, PS)은 두 개의 괄호 기호인 ‘(’ 와 ‘)’ 만으로 구성되어 있는 문자열이다. 
그 중에서 괄호의 모양이 바르게 구성된 문자열을 올바른 괄호 문자열(Valid PS, VPS)이라고 부른다. 
한 쌍의 괄호 기호로 된 “( )” 문자열은 기본 VPS 이라고 부른다. 
만일 x 가 VPS 라면 이것을 하나의 괄호에 넣은 새로운 문자열 “(x)”도 VPS 가 된다. 
그리고 두 VPS x 와 y를 접합(concatenation)시킨 새로운 문자열 xy도 VPS 가 된다. 
예를 들어 “(())()”와 “((()))” 는 VPS 이지만 “(()(”, “(())()))” , 그리고 “(()” 는 모두 VPS 가 아닌 문자열이다.
여러분은 입력으로 주어진 괄호 문자열이 VPS 인지 아닌지를 판단해서 그 결과를 YES 와 NO 로 나타내어야 한다.&lt;/p&gt;

&lt;h2 id=&quot;문제-분석&quot;&gt;문제 분석&lt;/h2&gt;

&lt;p&gt;문제는 짝을 지어주는 것으로 해결한다.
문자열을 입력받아서 괄호의 짝을 찾아주는 것이 문제 해결의 핵심이다.
“()()()()(“ 이러한 괄호가 들어온다면 NO를 출력해 주고, “()()()()”라는 문자열이 들어온다면 괄호의 모든 짝이 있으므로
POP으로 스택에서 제거해 주면 된다. 사실 벡터로도 풀 수 있을 거 같긴 한데 나는 스택을 이용해서 해결했다.&lt;/p&gt;

&lt;h2 id=&quot;코드&quot;&gt;코드&lt;/h2&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt;&lt;span class=&quot;cpf&quot;&gt;&amp;lt;bits/stdc++.h&amp;gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;check&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'('&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;cin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;check&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)){&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;YES&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;NO&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;실력이 점점 늘고 있다~~&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;1133&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/e7564843-db7b-49ce-b206-79ced6812d65&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;p&gt;나의 뇌&lt;/p&gt;
</description>
        <pubDate>Thu, 17 Oct 2024 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/cs/2024/10/17/Algorithm-19/</link>
        <guid isPermaLink="true">http://localhost:4000/cs/2024/10/17/Algorithm-19/</guid>
        
        <category>Algorithm</category>
        
        
        <category>cs</category>
        
      </item>
    
      <item>
        <title>Java Adv 15 - CAS operation - 1</title>
        <description>&lt;h2 id=&quot;락-기반-방식의-문제점&quot;&gt;락 기반 방식의 문제점&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SyncInteger&lt;/code&gt; 와 같은 클래스는 데이터를 보호하기 위해 락을 사용한다.
여기서 말하는 락은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;synchronized&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lock(ReentrantLock)&lt;/code&gt; 등을 사용하는 것을 말한다.
락은 특정 자원을 보호하기 위해 스레드가 해당 자원에 대한 접근하는 것을 제한한다. 
락이 걸려 있는 동안 다른 스레드들은 해당 자원에 접근할 수 없고, 락이 해제될 때까지 대기해야 한다. 
또한 락 기반 접근에서는 락을 획득하고 해제하는 데 시간이 소요된다. 예를 들어서 락을 사용하는 연산이 있다고 가정하자. 
락을 사용하는 방식은 다음과 같이 작동한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;락이 있는지 확인한다.&lt;/li&gt;
  &lt;li&gt;락을 획득하고 임계 영역에 들어간다.&lt;/li&gt;
  &lt;li&gt;작업을 수행한다.&lt;/li&gt;
  &lt;li&gt;락을 반납한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;여기서 락을 획득하고 반납하는 과정이 계속 반복된다. 
10000번의 연산이 있다면 10000번의 연산 모두 같은 과정을 반복한다. 
이렇듯 락을 사용하는 방식은 직관적이지만 상대적으로 무거운 방식이다.&lt;/p&gt;

&lt;h2 id=&quot;cas&quot;&gt;CAS&lt;/h2&gt;

&lt;p&gt;이런 문제를 해결하기 위해 락을 걸지 않고 원자적인 연산을 수행할 수 있는 방법이 있는데, 
이것을 CAS(Compare-And-Swap, Compare-And-Set) 연산이라 한다. 
이 방법은 락을 사용하지 않기 때문에 락 프리(lock-free) 기법이라한다. 
참고로 CAS 연산은 락을 완전히 대체하는 것은 아니고, &lt;strong&gt;작은&lt;/strong&gt; &lt;strong&gt;단위의&lt;/strong&gt; &lt;strong&gt;일부&lt;/strong&gt; &lt;strong&gt;영역에&lt;/strong&gt; &lt;strong&gt;적용&lt;/strong&gt;할 수 있다. 
기본은 락을 사용하고, 특별한 경우에 CAS를 적용할 수 있다고 생각하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;677&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/80113216-229d-441f-b469-63a5d246d570&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;compareandset0-1&quot;&gt;compareAndSet(0, 1)&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;atomicInteger&lt;/code&gt; 가 가지고 있는 값이 현재 0이면 이 값을 1로 변경하라는 매우 단순한 메서드이다. 
만약 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;atomicInteger&lt;/code&gt; 의 값이 현재 0이라면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;atomicInteger&lt;/code&gt; 의 값은 1로 변경된다. 
이 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;true&lt;/code&gt; 를 반환한다. 만약 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;atomicInteger&lt;/code&gt; 의 값이 현재 0이 아니라면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;atomicInteger&lt;/code&gt; 의 값은 변경되지 않는다. 이 경우&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;false&lt;/code&gt; 를 반환한다. 
여기서 가장 중요한 내용이 있는데, &lt;strong&gt;**이&lt;/strong&gt; &lt;strong&gt;메서드는&lt;/strong&gt; &lt;strong&gt;원자적으로&lt;/strong&gt; &lt;strong&gt;실행&lt;/strong&gt;**된다는 점이다. 
그리고 이 메서드가 제공하는 기능이 바로 CAS(compareAndSet) 연산이다.&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;p&gt;김영한님의 자바 강의&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://naveen-metta.medium.com/atomic-operations-in-java-mastering-thread-safety-and-concurrency-7c3360ec0bc5&quot;&gt;https://naveen-metta.medium.com/atomic-operations-in-java-mastering-thread-safety-and-concurrency-7c3360ec0bc5&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Wed, 16 Oct 2024 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/language/2024/10/16/Java-Adv-15/</link>
        <guid isPermaLink="true">http://localhost:4000/language/2024/10/16/Java-Adv-15/</guid>
        
        <category>java</category>
        
        
        <category>language</category>
        
      </item>
    
      <item>
        <title>Java Adv 14 - atomic operation - 3</title>
        <description>&lt;h2 id=&quot;atomicinteger&quot;&gt;AtomicInteger&lt;/h2&gt;

&lt;p&gt;자바는 앞서 만든 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SyncInteger&lt;/code&gt; 와 같이 멀티스레드 상황에서 안전하게 증가 연산을 수행할 수 있는
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AtomicInteger&lt;/code&gt; 라는 클래스를 제공한다. 이름 그대로 원자적인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Integer&lt;/code&gt; 라는 뜻이다.
다음과 같이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MyAtomicInteger&lt;/code&gt; 클래스를 만들고, 자바가 제공하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AtomicInteger&lt;/code&gt; 를 사용해보자.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;695&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/d20a0dea-2ee7-4577-9cfd-a861fddb0608&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new AtomicInteger(0)&lt;/code&gt; : 초기값을 지정한다. 생략하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt; 부터 시작한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;incrementAndGet()&lt;/code&gt; : 값을 하나 증가하고 증가된 결과를 반환한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;get()&lt;/code&gt; : 현재 값을 반환한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img width=&quot;695&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/d8aff3ae-62b9-4519-b5c8-c3b72f1ec98b&quot; /&gt;&lt;/p&gt;

&lt;p&gt;실행 결과를 보면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AtomicInteger&lt;/code&gt; 를 사용하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MyAtomicInteger&lt;/code&gt; 의 결과도 1000인 것을 확인할 수 있다.
1000개의 스레드가 안전하게 증가 연산을 수행한 것이다.
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AtomicInteger&lt;/code&gt; 는 멀티스레드 상황에 안전하고 또 다양한 값 증가, 감소 연산을 제공한다. 
특정 값을 증가하거나 감소해야 하는데 여러 스레드가 해당 값을 공유해야 한다면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AtomicInteger&lt;/code&gt; 를 사용하면 된다.&lt;/p&gt;

&lt;h2 id=&quot;성능-테스트&quot;&gt;성능 테스트&lt;/h2&gt;

&lt;p&gt;&lt;img width=&quot;695&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/7ccee411-b642-4613-8c81-575e54924778&quot; /&gt;
&lt;img width=&quot;695&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/b6c11592-7c41-4e95-b4b7-55e2ec12d589&quot; /&gt;
&lt;img width=&quot;695&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/83c9b4c9-0c63-452c-b2ff-ed2f58363fa5&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;BasicInteger
    &lt;ul&gt;
      &lt;li&gt;가장 빠르다.&lt;/li&gt;
      &lt;li&gt;CPU 캐시를 적극 사용한다. CPU 캐시의 위력을 알 수 있다.&lt;/li&gt;
      &lt;li&gt;안전한 임계 영역도 없고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;volatile&lt;/code&gt;도 사용하지 않기 때문에 멀티스레드 상황에는 사용할 수 없다.&lt;/li&gt;
      &lt;li&gt;단일 스레드가 사용하는 경우에 효율적이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;VolatileInteger
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;volatile&lt;/code&gt; 을 사용해서 CPU 캐시를 사용하지 않고 메인 메모리를 사용한다.&lt;/li&gt;
      &lt;li&gt;안전한 임계 영역이 없기 때문에 멀티스레드 상황에는 사용할 수 없다.&lt;/li&gt;
      &lt;li&gt;단일 스레드가 사용하기에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BasicInteger&lt;/code&gt; 보다 느리다. 그리고 멀티스레드 상황에도 안전하지 않다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;SyncInteger
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;synchronized&lt;/code&gt; 를 사용한 안전한 임계 영역이 있기 때문에 멀티스레드 상황에도 안전하게 사용할 수 있다.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MyAtomicInteger&lt;/code&gt; 보다 성능이 느리다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;MyAtomicInteger
    &lt;ul&gt;
      &lt;li&gt;자바가 제공하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AtomicInteger&lt;/code&gt; 를 사용한다. 멀티스레드 상황에 안전하게 사용할 수 있다.&lt;/li&gt;
      &lt;li&gt;성능도 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;synchronized&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lock(ReentrantLock)&lt;/code&gt; 을 사용하는 경우보다 1.5 ~ 2배 정도 빠르다.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SyncInteger&lt;/code&gt; 처럼 락을 사용하는 경우보다, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AtomicInteger&lt;/code&gt; 가 더 빠른 이유는 무엇일까? &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i++&lt;/code&gt; 연산은 원자적인 연산이 아니다.&lt;/li&gt;
      &lt;li&gt;따라서 분명히 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;synchronized&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lock(ReentrantLock)&lt;/code&gt; 와 같은 락을 통해 안전한 임계 영역을 만들어야 할 것 같다.&lt;/li&gt;
      &lt;li&gt;놀랍게도 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AtomicInteger&lt;/code&gt; 가 제공하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;incrementAndGet()&lt;/code&gt; 메서드는 락을 사용하지 않고, 원자적 연산을 만들어낸다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;p&gt;김영한님의 자바 강의&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://naveen-metta.medium.com/atomic-operations-in-java-mastering-thread-safety-and-concurrency-7c3360ec0bc5&quot;&gt;https://naveen-metta.medium.com/atomic-operations-in-java-mastering-thread-safety-and-concurrency-7c3360ec0bc5&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Tue, 15 Oct 2024 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/language/2024/10/15/Java-Adv-14/</link>
        <guid isPermaLink="true">http://localhost:4000/language/2024/10/15/Java-Adv-14/</guid>
        
        <category>java</category>
        
        
        <category>language</category>
        
      </item>
    
      <item>
        <title>Java Adv 13 - atomic operation - 2</title>
        <description>&lt;h2 id=&quot;atomic-operation-thread&quot;&gt;atomic operation Thread&lt;/h2&gt;

&lt;p&gt;&lt;img width=&quot;695&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/507aaa1f-ab38-4715-b4a3-456996cbe944&quot; /&gt;&lt;/p&gt;

&lt;p&gt;원자적이지 않은 연산을 멀티스레드 환경에서 실행하면 어떤 문제가 발생하는지 코드로 알아보자.
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IncrementInteger&lt;/code&gt; 는 숫자 값을 하나씩 증가시키는 기능을 제공한다. 
예를 들어서 지금까지 접속한 사용자의 수 등을 계산할 때 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;695&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/aa6dfdb1-d4b9-418c-b6a2-986cde809cce&quot; /&gt;&lt;/p&gt;

&lt;p&gt;1000개의 스레드가 increment 메서드를 호출하여 IncrementInteger 객체의 값을 증가시키도록 한다. 
모든 스레드가 종료된 후, 최종 증가된 값을 출력한다.
대기 시간을 두는 이유는 모든 스레드가 동시에 increment()를 호출하면 각 스레드가 접근하는 타이밍이 거의 같아 경쟁 조건이 발생하지 않거나 최소한으로 발생할 수 있다.
그러나 sleep(10)을 추가하면 스레드들이 순차적으로 약간의 시간 차이를 두고 메서드에 접근하게 되면서, 이미 increment() 
연산을 진행 중인 다른 스레드와 동시에 겹쳐서 자원에 접근할 가능성이 높아진다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;695&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/5a976264-1bff-426e-82f9-840b1b9aca26&quot; /&gt;
&lt;img width=&quot;695&quot; alt=&quot;image&quot; src=&quot;https://github.com/user-attachments/assets/842d7b2d-a758-4a12-ba28-074ad0398b95&quot; /&gt;&lt;/p&gt;

&lt;p&gt;실행 결과를 보면 기대한 1000이 아니라 다른 숫자가 보인다. 아마도 실행 환경에 따라서 다르겠지만 1000이 아니라
조금 더 적은 숫자가 보일 것이다. 물론 실행 환경에 따라서 1000이 보일 수도 있다.
이 문제는 앞서 설명한 것 처럼 여러 스레드가 동시에 원자적이지 않은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;value++&lt;/code&gt; 을 호출했기 때문에 발생한다.
그럼 혹시 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;volatile&lt;/code&gt; 을 적용하면 될까?&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;p&gt;김영한님의 자바 강의&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://naveen-metta.medium.com/atomic-operations-in-java-mastering-thread-safety-and-concurrency-7c3360ec0bc5&quot;&gt;https://naveen-metta.medium.com/atomic-operations-in-java-mastering-thread-safety-and-concurrency-7c3360ec0bc5&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 14 Oct 2024 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/language/2024/10/14/Java-Adv-13/</link>
        <guid isPermaLink="true">http://localhost:4000/language/2024/10/14/Java-Adv-13/</guid>
        
        <category>java</category>
        
        
        <category>language</category>
        
      </item>
    
  </channel>
</rss>
